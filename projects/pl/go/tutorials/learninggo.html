<!DOCTYPE html>
<html>
<head>
  <title>Learning Go</title>
  <meta name="GENERATOR" content="github.com/mmarkdown/mmark Mmark Markdown Processor - mmark.miek.nl">
  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="inc/learninggo.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script src="inc/prism.js"></script>

<script>
    $(document).ready(function() {
      $("body").wrapInner("<div class=\"book\"></div>")

      answers();
      chapters();
      figures();
      tables();

      references();
      links();
    });

    function chapters(){
        $("section[data-matter='main'] > h1:not(.special):not(.title)").each(function(index){
        $(this).prepend("Chapter " + (index+1) + ". ")
      })
    }

    function tables(){
        $("table + figcaption").each(function(index){
        $(this).prepend("Table " + (index+1) + ". ")
      })
    }

    function figures(){
        $("pre + figcaption, p + figcaption").each(function(index){
        $(this).prepend("Figure " + (index+1) + ". ")
      })
    }

    function references(){
      $("a:empty, [href^='#']").each(
        function(){
          var xid = $(this).attr("href");
          // Split out the different things we can reference.
          if ($(xid).is("table")) {
              $(this).append("Table " + ($("table").index($(xid)) + 1));
              return;
          }
          if ($(xid).is("figure")) {
              $(this).append("Figure " + ($("figure").index($(xid)) + 1));
              return;
          }
          if ($(xid).is(".bibliography-cite")) {
              return;
          }
          var val = $(xid).text();
          $(this).append(val);
        }
      );
    }

    function links() {
        return $(":header[id]").each(function(i, el) {
            var $el, icon, id;
            $el = $(el);
            id = $el.attr('id');
            icon = '<i>&para;</i>';
            if (id) {
                return $el.prepend($("<a />").addClass("header-link").attr("href",
                        window.location.pathname + "#" + id).html(icon));
            }
        });
    }

   function answers() {
        $("h3:contains('Answer')").addClass("closed")

        $("h3:contains('Answer')").each(function() {
           $(this).click(function(){ $(this).nextUntil("h1,h2,h3").slideToggle("fast");
                $(this).toggleClass("open closed");
           });
           $(this).nextUntil("h1,h2,h3").slideUp();
        });
   }
</script>
</head>
<body>

<h1 class="special" id="preface">Preface</h1>

<p>The <a href="https://github.com/miekg/learninggo">source of this book</a> is written in
<a href="https://mmark.nl">mmark</a> and is converted from the <a href="https://github.com/miekg/gobook">original LaTeX source</a>.</p>

<p><em>All example code used in this book is hereby licensed under the Apache License version 2.0.</em></p>

<blockquote>
<p>This work is licensed under the Attribution-NonCommercial-ShareAlike 3.0 Unported License. To
view a copy of this license, visit <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">http://creativecommons.org/licenses/by-nc-sa/3.0/</a>
or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.</p>
</blockquote>

<p>The following people made large or small contributions to earlier versions of this book:</p>

<p>Adam J. Gray,
Alexander Katasonov,
Alexey Chernenkov,
Alex Sychev,
Andrea Spadaccini,
Andrey Mirtchovski,
Anthony Magro,
Babu Sreekanth,
Ben Bullock,
Bob Cunningham,
Brian Fallik,
Cecil New,
Cobold,
Damian Gryski,
Daniele Pala,
Dan Kortschak,
David Otton,
Fabian Becker,
Filip Zaludek,
Hadi Amiri,
Haiping Fan,
Iaroslav Tymchenko,
Jaap Akkerhuis,
JC van Winkel,
Jeroen Bulten,
Jinpu Hu,
John Shahid,
Jonathan Kans,
Joshua Stein,
Makoto Inoue,
Marco Ynema,
Mayuresh Kathe,
Mem,
Michael Stapelberg,
Nicolas Kaiser,
Olexandr Shalakhin,
Paulo Pinto,
Peter Kleiweg,
Philipp Schmidt,
Robert Johnson,
Russel Winder,
Simoc,
Sonia Keys,
Stefan Schroeder,
Thomas Kapplet,
T.J. Yang,
Uriel<span class="math inline">\(\dagger\)</span>,
Vrai Stacey,
Xing Xing.</p>

<p>&ldquo;Learning Go&rdquo; has been translated into (note that this used the original LaTeX source).</p>

<ul>
<li>Chinese, by Xing Xing, 这里是中文译本: <a href="http://www.mikespook.com/learning-go/">http://www.mikespook.com/learning-go/</a></li>
</ul>

<p>I hope this book is useful.</p>

<p>Miek Gieben, London, 2015.</p>

<p>This book still sees development, small incremental improvements trickle in from Github.</p>

<p>Miek Gieben, London, 2017.</p>

<p>Learning Go&rsquo;s source has been rewritten in <a href="https://github.com/mmarkdown/mmark">mmark2</a>, but did not see any
other changes. This books translates cleanly into an <a href="learninggo-2.txt">RFC-like document</a>.</p>

<p>Miek Gieben, London, 2018.</p>
<section data-matter="main">
<h1 id="learning-go" class="title">Learning Go</h1>
<figure><p><img src="fig/bumper-inverse.png" alt="" /></p>

</figure>

<h1 id="introduction">Introduction</h1>
<figure>
<blockquote class="epigraph">
<p>Is Go an object-oriented language? Yes and no.</p>

<hr>
</blockquote>
<figcaption>Frequently asked questions, Go Authors
</figcaption>
</figure>

<p>The Go programming language is an open source project language to make programmers more productive.</p>

<p>According to the website <cite class="informative"><a href="#go_web"><sup>[go_web]</sup></a></cite> &ldquo;Go is expressive, concise, clean, and efficient&rdquo;. And indeed it
is. My initial interest was piqued when I read early announcements about this new language that had
built-in concurreny and a C-like syntax (Erlang also has built-in concurrency, but I could never get
used to its syntax). Go is a compiled statically typed language that feels like a dynamically typed,
interpreted language. My go to (scripting!) language Perl has taken a back seat now that Go is
around.</p>

<p>The unique Go language is defined by these principles:</p>

<dl>
<dt>Clean and Simple</dt>
<dd>Go strives to keep things small and beautiful. You should be able to do a lot in only a few
lines of code.</dd>
<dt>Concurrent</dt>
<dd>Go makes it easy to &ldquo;fire off&rdquo; functions to be run as <em>very</em> lightweight threads. These threads
are called goroutines <span class="index" id="idxref:0"></span><sup class="footnote-ref" id="fnref:Yes-that-sounds"><a href="#fn:Yes-that-sounds">1</a></sup> in Go.</dd>
<dt>Channels</dt>
<dd>Communication with these goroutines is done, either via shared state or via <span class="index" id="idxref:1"></span>
channels <cite class="informative"><a href="#csp"><sup>[csp]</sup></a></cite>.</dd>
<dt>Fast</dt>
<dd>Compilation is fast and execution is fast. The aim is to be as fast as C. Compilation time is
measured in seconds.</dd>
<dt>Safe</dt>
<dd>Explicit casting and strict rules when converting one type to another. Go has garbage
collection. No more <code>free()</code> in Go: the language takes care of this.</dd>
<dt>Standard format</dt>
<dd>A Go program can be formatted in (almost) any way the programmers want, but an official format
exists. The rule is very simple: The output of the filter <code>gofmt</code> <em>is the officially endorsed
format</em>.</dd>
<dt>Postfix types</dt>
<dd>Types are given <em>after</em> the variable name, thus <code>var a int</code>, instead of <code>int a</code>.</dd>
<dt>UTF-8</dt>
<dd>UTF-8 is everywhere, in strings <em>and</em> in the program code. Finally you can use <span class="math inline">\(\Phi = \Phi + 1\)</span>
in your source code.</dd>
<dt>Open Source</dt>
<dd>The Go license is completely open source.</dd>
<dt>Fun</dt>
<dd>Programming with Go should be fun!</dd>
</dl>

<p>As I mentioned Erlang also shares some features of Go. A notable difference between Erlang and Go is
that Erlang borders on being a functional language, while Go is imperative. And Erlang runs in
a virtual machine, while Go is compiled.</p>

<h2 id="how-to-read-this-book">How to Read this Book</h2>

<p>I&rsquo;ve written this book for people who already know some programming languages and how to program. In
order to use this book, you (of course) need Go installed on your system, but you can easily try
examples online in the Go playground<sup class="footnote-ref" id="fnref:http-play-golang"><a href="#fn:http-play-golang">2</a></sup>. All exercises in this book work
with Go 1, the first stable release of Go &ndash; if not, it&rsquo;s a bug.</p>

<p>The best way to learn Go is to create your own programs. Each chapter therefore includes exercises
(and answers to exercises) to acquaint you with the language. Each exercise is either <em>easy</em>,
<em>intermediate</em>, or <em>difficult</em>. The answers are included after the exercises on a new page. Some
exercises don&rsquo;t have an answer; these are marked with an asterisk.</p>

<p>Here&rsquo;s what you can expect from each chapter:</p>

<dl>
<dt><a href="#basics"></a></dt>
<dd>We&rsquo;ll look at the basic types, variables, and control structures available in the language.</dd>
<dt><a href="#functions"></a></dt>
<dd>Here we look at functions, the basic building blocks of Go programs.</dd>
<dt><a href="#packages"></a></dt>
<dd>We&rsquo;ll see that functions and data can be grouped together in packages. We&rsquo;ll also see how to
document and test our packages.</dd>
<dt><a href="#beyond-the-basics"></a></dt>
<dd>We&rsquo;ll create our own types. We&rsquo;ll also look at memory allocations in Go.</dd>
<dt><a href="#interfaces"></a></dt>
<dd>We&rsquo;ll learn how to use interfaces. Interfaces are the central concept in Go,
as Go does not support object orientation in the traditional sense.</dd>
<dt><a href="#concurrency"></a></dt>
<dd>We&rsquo;ll learn the <code>go</code> keyword, which can be used to start function in separate routines (called
goroutines). Communication with those goroutines is done via channels.</dd>
<dt><a href="#communication"></a></dt>
<dd>Finally we&rsquo;ll see how to interface with the rest of the world from within a Go program. We&rsquo;ll
see how to create files and read and write to and from them. We&rsquo;ll also briefly look into
networking.</dd>
</dl>

<h2 id="official-documentation">Official Documentation</h2>

<p>There is a substantial amount of documentation written about Go. The Go Tutorial <cite class="informative"><a href="#go_tutorial"><sup>[go_tutorial]</sup></a></cite>, the
Go Tour (with lots of exercises) and the Effective Go <cite class="informative"><a href="#effective_go"><sup>[effective_go]</sup></a></cite> are helpful resources. The
website <a href="http://golang.org/doc/">http://golang.org/doc/</a> is a very good starting point for reading up on
Go<sup class="footnote-ref" id="fnref:http-golang-org"><a href="#fn:http-golang-org">3</a></sup>. Reading these documents is certainly not
required, but it is recommended.</p>

<blockquote>
<p>When searching on the internet use the term &ldquo;golang&rdquo; instead of plain &ldquo;go&rdquo;.</p>
</blockquote>

<p>Go comes with its own documentation in the form of a program called <code>godoc</code><sup class="footnote-ref" id="fnref:When-building-fr"><a href="#fn:When-building-fr">4</a></sup>. If you are
interested in the documentation for the built-ins, simply do this:</p>

<pre><code>% godoc builtin
</code></pre>

<p>To get the documentation of the <code>hash</code> package, just:</p>

<pre><code>% godoc hash
</code></pre>

<p>To read the documentation of <code>fnv</code> contained in <code>hash</code>, you&rsquo;ll need to issue <code>godoc hash/fnv</code> as
<code>fnv</code> is a subdirectory of <code>hash</code>.</p>

<pre><code class="language-go">PACKAGE DOCUMENTATION

package fnv
    import &quot;hash/fnv&quot;

    Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash
    ...
</code></pre>

<h1 id="basics">Basics</h1>
<figure>
<blockquote class="epigraph">
<p>I am interested in this and hope to do something.</p>

<hr>
</blockquote>
<figcaption>On adding complex numbers to Go, Ken Thompson
</figcaption>
</figure>

<p>In this chapter we will look at the basic building blocks of the Go programming
language.</p>

<h2 id="hello-world">Hello World</h2>

<p>In the Go tutorial, you get started with Go in the typical manner: printing
&ldquo;Hello World&rdquo; (Ken Thompson and Dennis Ritchie started this when they presented
the C language in the 1970s). That&rsquo;s a great way to start, so here it is, &ldquo;Hello
World&rdquo; in Go.</p>

<pre><code class="language-go">package main <span class="callout">1</span>

import &quot;fmt&quot; <span class="callout">2</span> // Implements formatted I/O.

/* Print something */ <span class="callout">3</span>
func main() {         <span class="callout">4</span>
	fmt.Printf(&quot;Hello, world.&quot;) <span class="callout">5</span>
}
</code></pre>

<p>Lets look at the program line by line. This first line is just required <span class="callout">1</span>. All
Go files start with <code>package &lt;something&gt;</code>, and <code>package main</code> is required for
a standalone executable.</p>

<p><code>import &quot;fmt&quot;</code> says we need <code>fmt</code> in addition to <code>main</code> <span class="callout">2</span>. A package other
than <code>main</code> is commonly called a library, a familiar concept in many programming
languages (see <a href="#packages"></a>). The line ends with a comment that begins with <code>//</code>.</p>

<p>Next we another comment, but this one is enclosed in <code>/*</code> <code>*/</code> <span class="callout">3</span>. When your Go
program is executed, the first function called will be <code>main.main()</code>, which
mimics the behavior from C. Here we declare that function <span class="callout">4</span>.</p>

<p>Finally we call a function from the package <code>fmt</code> to print a string to the
screen. The string is enclosed with <code>&quot;</code> and may contain non-ASCII characters
<span class="callout">5</span>.</p>

<h2 id="compiling-and-running-code">Compiling and Running Code</h2>

<p>To build a Go program, use the <code>go</code> tool.<span class="index" id="idxref:2"></span>
To build <code>helloworld</code> we just enter:</p>

<pre><code>% go build helloworld.go
</code></pre>

<p><span class="index" id="idxref:3"></span>
This results in an executable called <code>helloworld</code>. <span class="index" id="idxref:4"></span></p>

<pre><code>% ./helloworld
Hello, world.
</code></pre>

<p>You can combine the above and just call <code>go run helloworld.go</code>.</p>

<h2 id="variables-types-and-keywords">Variables, Types and Keywords</h2>

<p>In the next few sections we will look at the variables, basic types, keywords,
and control structures of our new language.</p>

<p>Go is different from (most) other languages in that the type of a variable is
specified <em>after</em> the variable name. So not: <code>int a</code>, but <code>a int</code>. When you
declare a variable it is assigned the &ldquo;natural&rdquo; null value for the type. This
means that after <code>var a int</code>, <code>a</code> has a value of 0. With <code>var s string</code>, <code>s</code> is
assigned the zero string, which is <code>&quot;&quot;</code>. Declaring and assigning in Go is a two
step process, but they may be combined. Compare the following pieces of code
which have the same effect. <span class="index" id="idxref:5"></span> <span class="index" id="idxref:6"></span></p>

<pre><code class="language-go">var a int                           a := 15
var b bool                          b := false
a = 15
b = false
</code></pre>

<p>On the left we use the <code>var</code> keyword to declare a variable and <em>then</em> assign
a value to it. The code on the right uses <code>:=</code> to do this in one step (this form
may only be used <em>inside</em> functions). In that case the variable type is
<em>deduced</em> from the value. A value of 15 indicates an <code>int</code>. A value of <code>false</code>
tells Go that the type should be <code>bool</code>. Multiple <code>var</code> declarations may also
be grouped; <code>const</code> (see <a href="#constants"></a>) and <code>import</code> also allow this. Note the
use of parentheses instead of braces:</p>

<pre><code class="language-go">var (
    x int
    b bool
)
</code></pre>

<p>Multiple variables of the same type can also be declared on a single line: <code>var
x, y int</code> makes <code>x</code> and <code>y</code> both <code>int</code> variables. You can also make use of
<em>parallel assignment</em><span class="index" id="idxref:7"></span> <code>a, b := 20, 16</code>.
This makes <code>a</code> and <code>b</code> both integer variables and assigns
20 to <code>a</code> and 16 to <code>b</code>.</p>

<p>A special name for a variable is <code>_</code>. <span class="index" id="idxref:8"></span> Any value
assigned to it is discarded (it&rsquo;s similar to <code>/dev/null</code> on Unix). In this
example we only assign the integer value of 35 to <code>b</code> and discard the value 34:
<code>_, b := 34, 35</code>. Declared but otherwise <em>unused</em> variables are a compiler error
in Go.</p>

<h3 id="boolean-types">Boolean Types</h3>

<p>A boolean type represents the set of boolean truth values denoted by the
predeclared constants <em>true</em> and <em>false</em>. The boolean type is <code>bool</code>.</p>

<h3 id="numerical-types">Numerical Types</h3>

<p>Go has most of the well-known types such as <code>int</code>. The <code>int</code> type has the
appropriate length for your machine, meaning that on a 32-bit machine it is 32
bits and on a 64-bit machine it is 64 bits. Note: an <code>int</code> is either 32 or 64
bits, no other values are defined. Same goes for <code>uint</code>, the unsigned int.</p>

<p>If you want to be explicit about the length, you can have that too, with
<code>int32</code>, or <code>uint32</code>. The full list for (signed and unsigned) integers is
<code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> and <code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>,
<code>uint64</code>, with <code>byte</code> being an alias for <code>uint8</code>. For floating point values
there is <code>float32</code> and <code>float64</code> (there is no <code>float</code> type). A 64 bit integer or
floating point value is <em>always</em> 64 bit, also on 32 bit architectures.</p>

<p>Note that these types are all distinct and assigning variables which mix these
types is a compiler error, like in the following code:</p>

<pre><code class="language-go">package main

func main() {
	var a int
	var b int32
	b = a + a
	b = b + 5
}
</code></pre>

<p>We declare two different integers, a and b where a is an <code>int</code> and b is an
<code>int32</code>. We want to set b to the sum of a and a. This fails and gives the error:
<code>cannot use a + a (type int)  as type int32 in assignment</code>. Adding the constant
5 to b <em>does</em> succeed, because constants are not typed.</p>

<h3 id="constants">Constants</h3>

<p>Constants in Go are just that &mdash; constant. They are created at compile time,
and can only be numbers, strings, or booleans; <code>const x = 42</code> makes <code>x</code>
a constant. You can use
<em>iota</em><span class="index" id="idxref:9"></span> <sup class="footnote-ref" id="fnref:The-word-iota-is"><a href="#fn:The-word-iota-is">5</a></sup> to enumerate values.</p>

<pre><code class="language-go">const (
    a = iota
    b
)
</code></pre>

<p>The first use of <code>iota</code> will yield 0, so <code>a</code> is equal to 0. Whenever <code>iota</code> is
used again on a new line its value is incremented with 1, so <code>b</code> has a value of 1.
Or, as shown here, you can even let Go repeat the use of <code>iota</code>. You may also
explicitly type a constant: <code>const b string = &quot;0&quot;</code>. Now <code>b</code> is a <code>string</code> type
constant.</p>

<h3 id="strings">Strings</h3>

<p>Another important built-in type is <code>string</code>. Assigning a string is as simple as:</p>

<pre><code class="language-go">s := &quot;Hello World!&quot;
</code></pre>

<p>Strings in Go are a sequence of UTF-8 characters enclosed in double quotes (&ldquo;).
If you use the single quote (&lsquo;) you mean one character (encoded in UTF-8) &mdash;
which is <em>not</em> a <code>string</code> in Go.</p>

<p>Once assigned to a variable, the string cannot be changed: strings in Go are
immutable. If you are coming from C, note that the following is not legal in Go:</p>

<pre><code class="language-go">var s string = &quot;hello&quot;
s[0] = 'c'
</code></pre>

<p>To do this in Go you will need the following:</p>

<pre><code class="language-go">s := &quot;hello&quot;
c := []rune(s)	    <span class="callout">1</span>
c[0] = 'c'	        <span class="callout">2</span>
s2 := string(c)     <span class="callout">3</span>
fmt.Printf(&quot;%s\n&quot;, s2) <span class="callout">4</span>
</code></pre>

<p>Here we convert <code>s</code> to an array of runes <span class="callout">1</span>. We change the first element of
this array <span class="callout">2</span>. Then we create a <em>new</em> string <code>s2</code> with the alteration <span class="callout">3</span>.
Finally, we print the string with <code>fmt.Printf</code> <span class="callout">4</span>.</p>

<h3 id="runes">Runes</h3>

<p><code>Rune</code> is an alias for <code>int32</code>. It is an UTF-8 encoded code point. When is this
type useful? <span class="index" id="idxref:10"></span> One example is when you&rsquo;re iterating over characters in
a string. You could loop over each byte (which is only equivalent to a character
when strings are encoded in 8-bit ASCII, which they are <em>not</em> in Go!). But to
get the actual characters you should use the <code>rune</code> type.</p>

<h3 id="complex-numbers">Complex Numbers</h3>

<p>Go has native support for complex numbers. To use them you need a variable of
type <code>complex128</code> (64 bit real and imaginary parts) or <code>complex64</code> (32 bit real
and imaginary parts). Complex numbers are written as <code>re + im</code><span class="math inline">\(i\)</span>, where <code>re</code>
is the real part, <code>im</code> is the imaginary part and <span class="math inline">\(i\)</span> is the literal &lsquo;<span class="math inline">\(i\)</span>&rsquo;
(<span class="math inline">\(\sqrt{-1}\)</span>).</p>

<h3 id="errors">Errors</h3>

<p>Any non-trivial program will have the need for error reporting sooner or later.
Because of this Go has a builtin type specially for errors, called <code>error</code>. <code>var
e error</code> creates a variable <code>e</code> of type <code>error</code> with the value <code>nil</code>. This error
type is an interface &ndash; we&rsquo;ll look more at interfaces in <a href="#interfaces"></a>. For
now you can just assume that <code>error</code> is a type just like all other types.</p>

<h2 id="operators-and-built-in-functions">Operators and Built-in Functions</h2>

<p>Go supports the normal set of numerical operators. See <a href="#tab-op-precedence"></a>
for lists the current ones and their relative precedence. They all associate from
left to right.</p>
<figure>
<table id="tab-op-precedence">
<thead>
<tr>
<th>Precedence</th>
<th>Operator(s)</th>
</tr>
</thead>

<tbody>
<tr>
<td>Highest</td>
<td><code>*  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</code></td>
</tr>

<tr>
<td></td>
<td><code>+  -  | ^</code></td>
</tr>

<tr>
<td></td>
<td><code>==  !=  &lt;  &lt;=  &gt;  &gt;=</code></td>
</tr>

<tr>
<td></td>
<td><code>&lt;-</code></td>
</tr>

<tr>
<td></td>
<td><code>&amp;&amp;</code></td>
</tr>

<tr>
<td>Lowest</td>
<td>||</td>
</tr>
</tbody>
</table>
<figcaption>Operator precedence.</figcaption>
</figure>

<p><code>+ - * /</code> and <code>%</code> all do what you would expect, <code>&amp; | ^</code> and <code>&amp;^</code> are bit
operators for bitwise <em>and</em><span class="index" id="idxref:11"></span> bitwise
<em>or</em><span class="index" id="idxref:12"></span> bitwise <em>xor</em><span class="index" id="idxref:13"></span> and
bit clear <span class="index" id="idxref:14"></span> respectively. The <code>&amp;&amp;</code> and <code>||</code>
operators are logical <em>and</em> <span class="index" id="idxref:15"></span> and logical <em>or</em> <span class="index" id="idxref:16"></span> Not listed in the table is the logical not <span class="index" id="idxref:17"></span> <code>!</code></p>

<p>Although Go does not support operator overloading (or method overloading for
that matter), some of the built-in operators <em>are</em> overloaded. For instance, <code>+</code>
can be used for integers, floats, complex numbers and strings (adding strings is
concatenating them).</p>

<h2 id="go-keywords">Go Keywords</h2>

<p>Let&rsquo;s start looking at keywords, <a href="#tab-keywords"></a> lists all the keywords in
Go.</p>
<figure>
<table id="tab-keywords">
<tbody>
<tr>
<td><code>break</code></td>
<td><code>default</code></td>
<td><code>func</code></td>
<td><code>interface</code></td>
<td><code>select</code></td>
</tr>

<tr>
<td><code>case</code></td>
<td><code>defer</code></td>
<td><code>go</code></td>
<td><code>map</code></td>
<td><code>struct</code></td>
</tr>

<tr>
<td><code>chan</code></td>
<td><code>else</code></td>
<td><code>goto</code></td>
<td><code>package</code></td>
<td><code>switch</code></td>
</tr>

<tr>
<td><code>const</code></td>
<td><code>fallthrough</code></td>
<td><code>if</code></td>
<td><code>range</code></td>
<td><code>type</code></td>
</tr>

<tr>
<td><code>continue</code></td>
<td><code>for</code></td>
<td><code>import</code></td>
<td><code>return</code></td>
<td><code>var</code></td>
</tr>
</tbody>
</table>
<figcaption>Keywords in Go.</figcaption>
</figure>

<p>We&rsquo;ve seen some of these already. We used <code>var</code> and <code>const</code> in the <a href="#variables-types-and-keywords"></a>
section,  and we briefly looked at <code>package</code> and <code>import</code> in our &ldquo;Hello World&rdquo;
program at the start of the chapter. Others need more attention and have their
own chapter or section:</p>

<ul>
<li><code>func</code> is used to declare functions and methods.</li>
<li><code>return</code> is used to return from functions. We&rsquo;ll look at both <code>func</code> and <code>return</code> in detail in <a href="#functions"></a>.</li>
<li><code>go</code> is used for concurrency. We&rsquo;ll look at this in <a href="#channels"></a>.</li>
<li><code>select</code> used to choose from different types of communication, We&rsquo;ll work with <code>select</code> in <a href="#channels"></a>.</li>
<li><code>interface</code> is covered in <a href="#interfaces"></a>.</li>
<li><code>struct</code> is used for abstract data types. We&rsquo;ll work with <code>struct</code> in <a href="#beyond-the-basics"></a>.</li>
<li><code>type</code> is also covered in <a href="#beyond-the-basics"></a>.</li>
</ul>

<h2 id="control-structures">Control Structures</h2>

<p>There are only a few control structures in Go. To write loops we use the <code>for</code>
keyword, and there is a <code>switch</code> and of course an <code>if</code>. When working with
channels <code>select</code> will be used (see <a href="#channels"></a>). Parentheses are not
required around the condition, and the body must <em>always</em> be brace-delimited.</p>

<h3 id="if-else">If-Else</h3>

<p>In Go an <code>if</code> <span class="index" id="idxref:18"></span> looks like this:</p>

<pre><code class="language-go">if x &gt; 0 {
    return y
} else {
    return x
}
</code></pre>

<p><span class="index" id="idxref:19"></span> <span class="index" id="idxref:20"></span> Since <code>if</code> and <code>switch</code> accept an
initialization statement, it&rsquo;s common to see one used to set up a (local)
variable.</p>

<pre><code class="language-go">if err := SomeFunction(); err == nil {
    // do something
} else {
    return err
}
</code></pre>

<p>It is idomatic in Go to omit the <code>else</code> when the <code>if</code> statement&rsquo;s body has
a <code>break</code>, <code>continue</code>, <code>return</code> or, <code>goto</code>, so the above code would be better
written as:</p>

<pre><code class="language-go">if err := SomeFunction(); err != nil {
    return err
}
// do something
</code></pre>

<p>The opening brace on the first line must be positioned on the same line as the
<code>if</code> statement. There is no arguing about this, because this is what <code>gofmt</code>
outputs.</p>

<h3 id="goto">Goto</h3>

<p>Go has a <code>goto</code> <span class="index" id="idxref:21"></span> statement - use it wisely. With <code>goto</code> you
jump to a <span class="index" id="idxref:22"></span> label which must be defined within the current function.
For instance, a loop in disguise:</p>

<pre><code class="language-go">func myfunc() {
    i := 0
Here:
    fmt.Println(i)
    i++
    goto Here
}
</code></pre>

<p>The string <code>Here:</code> indicates a label. A label does not need to start with
a capital letter and is case sensitive.</p>

<h3 id="for">For</h3>

<p>The Go <code>for</code> <span class="index" id="idxref:23"></span> loop has three forms, only one of which has
semicolons:</p>

<ul>
<li><code>for init; condition; post { }</code> - a loop using the syntax borrowed from C;</li>
<li><code>for condition { }</code> - a while loop, and;</li>
<li><code>for { }</code> - an endless loop.</li>
</ul>

<p>Short declarations make it easy to declare the index variable right in the loop.</p>

<pre><code class="language-go">sum := 0
for i := 0; i &lt; 10; i++ {
    sum = sum + i
}
</code></pre>

<p>Note that the variable <code>i</code> ceases to exist after the loop.</p>

<h3 id="break-and-continue">Break and Continue</h3>

<p>With <code>break</code> <span class="index" id="idxref:24"></span> you can quit loops early.  By itself, <code>break</code>
breaks the current loop.</p>

<pre><code class="language-go">for i := 0; i &lt; 10; i++ {
    if i &gt; 5 {
    break <span class="callout">1</span>
    }
    fmt.Println(i) <span class="callout">2</span>
}
</code></pre>

<p>Here we <code>break</code> the current loop <span class="callout">1</span>, and don&rsquo;t continue with the
<code>fmt.Println(i)</code> statement <span class="callout">2</span>. So we only print 0 to 5. With loops within loop
you can specify a label after <code>break</code> to identify <em>which</em> loop to stop:</p>

<pre><code class="language-go">J:  for j := 0; j &lt; 5; j++ { <span class="callout">1</span>
        for i := 0; i &lt; 10; i++ {
            if i &gt; 5 {
                break J <span class="callout">2</span>
            }
            fmt.Println(i)
        }
    }
</code></pre>

<p>Here we define a label &ldquo;J&rdquo; <span class="callout">1</span>, preceding the <code>for</code>-loop there. When we use
<code>break J</code> <span class="callout">2</span>, we don&rsquo;t break the inner loop but the &ldquo;J&rdquo; loop.</p>

<p>With <code>continue</code> <span class="index" id="idxref:25"></span> you begin the next iteration of the
loop, skipping any remaining code. In the same way as <code>break</code>, <code>continue</code> also
accepts a label.</p>

<h3 id="range">Range</h3>

<p>The keyword <code>range</code> <span class="index" id="idxref:26"></span> can be used for loops. It can loop
over slices, arrays, strings, maps and channels (see <a href="#channels"></a>). <code>range</code> is an
iterator that, when called, returns the next key-value pair from the &ldquo;thing&rdquo; it
loops over. Depending on what that is, <code>range</code> returns different things.</p>

<p>When looping over a slice or array, <code>range</code> returns the index in the slice as
the key and value belonging to that index. Consider this code: <span class="index" id="idxref:27"></span></p>

<pre><code class="language-go">list := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}
for k, v := range list {
    // do something with k and v
}
</code></pre>

<p>First we create a slice of strings. Then we use <code>range</code> to loop over them. With
each iteration, <code>range</code> will return the index as an <code>int</code> and the key as
a <code>string</code>. It will start with 0 and &ldquo;a&rdquo;, so <code>k</code> will be 0 through 5, and v will
be &ldquo;a&rdquo; through &ldquo;f&rdquo;.</p>

<p>You can also use <code>range</code> on strings directly. Then it will break out the
individual Unicode characters <sup class="footnote-ref" id="fnref:In-the-UTF-8-wor"><a href="#fn:In-the-UTF-8-wor">6</a></sup> In this case the type of <code>char</code> is <code>rune</code>. and their start position, by
parsing the UTF-8. The loop: <span class="index" id="idxref:28"></span></p>

<pre><code class="language-go">for pos, char := range &quot;Gő!&quot; {
    fmt.Printf(&quot;character '%c' starts at byte position %d\n&quot;, char, pos)
}
</code></pre>

<p>prints</p>

<pre><code>character 'G' starts at byte position 0
character 'ő' starts at byte position 1
character '!' starts at byte position 3
</code></pre>

<p>Note that <code>ő</code> took 2 bytes, so &lsquo;!&rsquo; starts at byte 3.</p>

<h3 id="switch">Switch</h3>

<p>Go&rsquo;s <code>switch</code> <span class="index" id="idxref:29"></span> is very flexible; you can match on much
more than just integers. The cases are evaluated top to bottom until a match is
found, and if the <code>switch</code> has no expression it switches on <code>true</code>. It&rsquo;s
therefore possible &ndash; and idiomatic &ndash; to write an <code>if-else-if-else</code> chain as
a <code>switch</code>.</p>

<pre><code class="language-go">// Convert hexadecimal character to an int value
switch { <span class="callout">1</span>
case '0' &lt;= c &amp;&amp; c &lt;= '9': <span class="callout">2</span>
    return c - '0' <span class="callout">3</span>
case 'a' &lt;= c &amp;&amp; c &lt;= 'f': <span class="callout">4</span>
    return c - 'a' + 10
case 'A' &lt;= c &amp;&amp; c &lt;= 'F': <span class="callout">5</span>
    return c - 'A' + 10
}
return 0
</code></pre>

<p>A <code>switch</code> without a condition is the same as <code>switch true</code> <span class="callout">1</span>. We list the
different cases. Each <code>case</code> statement has a condition that is either true of
false. Here <span class="callout">2</span> we check if <code>c</code> is a number. If <code>c</code> is a number we return its
value <span class="callout">3</span>. Check if <code>c</code> falls between &ldquo;a&rdquo; and &ldquo;f&rdquo; <span class="callout">4</span>. For an &ldquo;a&rdquo; we
return 10, for &ldquo;b&rdquo; we return 11, etc. We also do the same <span class="callout">5</span> thing for &ldquo;A&rdquo;
to &ldquo;F&rdquo;.</p>

<p>There is no automatic fall through, you can use <code>fallthrough</code> <span class="index" id="idxref:30"></span> for that.</p>

<pre><code class="language-go">switch i {
    case 0:  fallthrough
    case 1: <span class="callout">1</span>
        f()
    default:
        g() <span class="callout">2</span>
</code></pre>

<p><code>f()</code> can be called when <code>i == 0</code> <span class="callout">1</span>. With <code>default</code> <span class="index" id="idxref:31"></span> you
can specify an action when none of the other cases match. Here <code>g()</code> is called
when <code>i</code> is not 0 or 1 <span class="callout">2</span>. We could rewrite the above example as:</p>

<pre><code class="language-go">switch i {
    case 0, 1: <span class="callout">1</span>
        f()
    default:
        g()
</code></pre>

<p>You can list cases on one line <span class="callout">1</span>, separated by commas.</p>

<h2 id="built-in-functions">Built-in Functions</h2>

<p>A few functions are predefined, meaning you <em>don&rsquo;t</em> have to include any package
to get access to them. <a href="#tab-predef-functions"></a> lists them all.<sup class="footnote-ref" id="fnref:You-can-use-the"><a href="#fn:You-can-use-the">7</a></sup></p>
<figure>
<table id="tab-predef-functions">
<tbody>
<tr>
<td><code>close</code></td>
<td><code>new</code></td>
<td><code>panic</code></td>
<td><code>complex</code></td>
</tr>

<tr>
<td><code>delete</code></td>
<td><code>make</code></td>
<td><code>recover</code></td>
<td><code>real</code></td>
</tr>

<tr>
<td><code>len</code></td>
<td><code>append</code></td>
<td><code>print</code></td>
<td><code>imag</code></td>
</tr>

<tr>
<td><code>cap</code></td>
<td><code>copy</code></td>
<td><code>println</code></td>
<td></td>
</tr>
</tbody>
</table>
<figcaption>Pre-defined functions in Go.</figcaption>
</figure>

<p>These built-in functions are documented in the <code>builtin</code> <span class="index" id="idxref:32"></span>
pseudo package that is included in recent Go releases. Let&rsquo;s go over these
functions briefly.</p>

<dl>
<dt><code>close</code></dt>
<dd>is used in channel communication. It closes a channel. We&rsquo;ll learn more about this in <a href="#channels"></a>.
<span class="index" id="idxref:33"></span></dd>
<dt><code>delete</code></dt>
<dd>is used for deleting entries in maps. <span class="index" id="idxref:34"></span></dd>
<dt><code>len</code> and <code>cap</code></dt>
<dd>are used on a number of different types, <code>len</code> is
used to return the lengths of strings, maps, slices, and
arrays. In the next section <a href="#arrays"></a> we&rsquo;ll look at slices,
arrays and the function <code>cap</code>.<span class="index" id="idxref:35"></span><span class="index" id="idxref:36"></span></dd>
<dt><code>new</code></dt>
<dd>is used for allocating memory for user defined
data types. See <a href="#allocation-with-new"></a>.
<span class="index" id="idxref:37"></span></dd>
<dt><code>make</code></dt>
<dd>is used for allocating memory for built-in
types (maps, slices, and channels). See <a href="#allocation-with-make"></a>.
<span class="index" id="idxref:38"></span></dd>
<dt><code>copy</code>, <code>append</code></dt>
<dd><code>copy</code> is for copying slices. <span class="index" id="idxref:39"></span>
And <code>append</code> is for concatenating slices. See <a href="#slices"></a> in this chapter. <span class="index" id="idxref:40"></span></dd>
<dt><code>panic</code>, <code>recover</code></dt>
<dd>are used for an <em>exception</em> mechanism. See <a href="#panic-and-recovering"></a> for more.
<span class="index" id="idxref:41"></span>
<span class="index" id="idxref:42"></span></dd>
<dt><code>print</code>, <code>println</code></dt>
<dd>are low level printing functions that can be used without reverting to the
<code>fmt</code> <span class="index" id="idxref:43"></span> package. These are mainly used for debugging.
<span class="index" id="idxref:44"></span>built-in,println)</dd>
<dt><code>complex</code>, <code>real</code>, <code>imag</code></dt>
<dd>all deal with complex numbers. <span class="index" id="idxref:45"></span> We will not use complex numbers in this book.
<span class="index" id="idxref:46"></span>
<span class="index" id="idxref:47"></span>
<span class="index" id="idxref:48"></span></dd>
</dl>

<h2 id="arrays-slices-and-maps">Arrays, Slices, and Maps</h2>

<p>To store multiple values in a list, you can use arrays, or their more flexible
cousin: slices. A dictionary or hash type is also available. It is called
a <code>map</code> in Go.</p>

<h3 id="arrays">Arrays</h3>

<p>An array is defined by: <code>[n]&lt;type&gt;</code>, where <span class="math inline">\(n\)</span> is the length of the array and
<code>&lt;type&gt;</code> is the stuff you want to store. To assign or index an element in the
array, you use square brackets:</p>

<pre><code class="language-go">var arr [10]int
arr[0] = 42
arr[1] = 13
fmt.Printf(&quot;The first element is %d\n&quot;, arr[0])
</code></pre>

<p>Array types like <code>var arr [10]int</code> have a fixed size. The size is <em>part</em> of the
type. They can&rsquo;t grow, because then they would have a different type. Also
arrays are values: Assigning one array to another <em>copies</em> all the elements. In
particular, if you pass an array to a function it will receive a copy of the
array, not a pointer to it.</p>

<p><span class="index" id="idxref:49"></span> To declare an array you can use the following: <code>var
a [3]int</code>. To initialize it to something other than zero, use a
<em>composite literal</em> <span class="index" id="idxref:50"></span> <code>a := [3]int{1, 2, 3}</code>. This can
 be shortened to <code>a := [...]int{1, 2, 3}</code>, where Go counts the elements
 automatically.</p>

<aside>
<p>A composite literal allows you
to assign a value directly to an array, slice, or map.
See <a href="#constructors-and-composite-literals"></a> for more information.</p>
</aside>

<p>When declaring arrays you <em>always</em> have to type something in between the square
brackets, either a number or three dots (<code>...</code>), when using a composite literal.
When using multidimensional arrays, you can use the following syntax: <code>a :=
[2][2]int{ {1,2}, {3,4} }</code>. Now that you know about arrays you will be delighted
to learn that you will almost never use them in Go, because there is something
much more flexible: slices.</p>

<h3 id="slices">Slices</h3>

<p>A slice is similar to an array, but it can grow when new elements are added.
A slice always refers to an underlying array. What makes slices different from
arrays is that a slice is a pointer <em>to</em> an array; slices are reference
types.<span class="index" id="idxref:51"></span></p>

<aside>
<p>Reference types are created with <code>make</code>. We detail this further
in <a href="#beyond-the-basics"></a>.</p>
</aside>

<p>That means that if you assign one slice to another, both refer to the <em>same</em>
underlying array. For instance, if a function takes a slice argument, changes it
makes to the elements of the slice will be visible to the caller, analogous to
passing a pointer to the underlying array. With: <code>slice := make([]int, 10)</code>, you
create a slice which can hold ten elements. Note that the underlying array isn&rsquo;t
specified. A slice is always coupled to an array that has a fixed size. For
slices we define a capacity <span class="index" id="idxref:52"></span> and a length
<span class="index" id="idxref:53"></span> The image below shows the creation of an array,
then the creation of a slice. First we create an array of <span class="math inline">\(m\)</span> elements of the
type <code>int</code>: <code>var array[m]int</code> .</p>

<p>Next, we create a slice from this array: <code>slice := array[:n]</code> . And now we have:</p>

<ul>
<li><code>len(slice) == n</code></li>
<li><code>cap(slice) == m</code></li>
<li><code>len(array) == cap(array) == m</code></li>
</ul>
<figure><p><img src="fig/array-vs-slice.png" alt="Array versus slice" /></p>
<figcaption>An array versus a slice.
</figcaption>
</figure>

<p>Given an array, or another slice, a new slice is created via <code>a[n:m]</code>. This
creates a new slice which refers to the variable <code>a</code>, starts at index <code>n</code>, and
ends before index <code>m</code>. It has length <code>n - m</code>.</p>

<pre><code class="language-go">a := [...]int{1, 2, 3, 4, 5} <span class="callout">1</span>
s1 := a[2:4] <span class="callout">2</span>
s2 := a[1:5] <span class="callout">3</span>
s3 := a[:]   <span class="callout">4</span>
s4 := a[:4]  <span class="callout">5</span>
s5 := s2[:] <span class="callout">6</span>
s6 := a[2:4:5] <span class="callout">7</span>
</code></pre>

<p>First we define <span class="callout">1</span> an array with five elements, from index 0 to 4.
From this we create <span class="callout">2</span> a slice with the elements from index 2 to 3, this slices contains: <code>3, 4</code>.
Then we we create another slice <span class="callout">3</span> from <code>a</code>: with the elements from index 1 to 4,
this contains: <code>2, 3, 4, 5</code>.
With <code>a[:]</code> <span class="callout">4</span> we create a slice with all the elements in the array. This is a shorthand for: <code>a[0:len(a)]</code>.
And with <code>a[:4]</code> <span class="callout">5</span> we create a slice with the elements from index
0 to 3, this is short for: <code>a[0:4]</code>, and gives us a slices that contains: <code>1, 2, 3, 4</code>.
With <code>s2[:]</code> we create a slice from the slice <code>s2</code> <span class="callout">6</span>, note that <code>s5</code> still refers to the array <code>a</code>.
Finally, we create a slice with the elements from index 3 to 3 <em>and</em> also set the cap to 4 <span class="callout">7</span>.</p>

<p>When working with slices you can overrun the bounds, consider this code.</p>

<pre><code class="language-go">package main

func main() {
	var array [100]int   <span class="callout">1</span>
	slice := array[0:99] <span class="callout">2</span>

	slice[98] = 1 <span class="callout">3</span>
	slice[99] = 2 <span class="callout">4</span>
}
</code></pre>

<p>At <span class="callout">1</span> we create an array with a 100 elements, indexed from 0 to 99. Then at <span class="callout">2</span>
we create a slice that has index 0 to 98. We assign 1 to the 99th element <span class="callout">3</span> of
the slice. This works as expected. But at <span class="callout">4</span> we dare to do the impossible, and
and try to allocate something beyond the length of the slice and we are greeted
with a <em>runtime</em> error: <code>Error: &quot;throw: index out of range&quot;.</code></p>

<p>If you want to extend a slice, there are a couple of built-in functions that
make life easier: <code>append</code> and <code>copy</code>. The append function appends zero or more
values to a slice and returns the result: a slice with the same type as the
original. If the original slice isn&rsquo;t big enough to fit the added values, append
will allocate a new slice that is big enough. So the slice returned by append
may refer to a different underlying array than the original slice does. Here&rsquo;s
an example: <span class="index" id="idxref:54"></span></p>

<pre><code class="language-go">s0 := []int{0, 0}
s1 := append(s0, 2) <span class="callout">1</span>
s2 := append(s1, 3, 5, 7) <span class="callout">2</span>
s3 := append(s2, s0...) <span class="callout">3</span>
</code></pre>

<p>At <span class="callout">1</span> we append a single element, making <code>s1</code> equal to <code>[]int{0, 0, 2}</code>. At <span class="callout">2</span>
we append multiple elements, making <code>s2</code> equal to <code>[]int{0, 0, 2, 3, 5, 7}</code>. And
at <span class="callout">3</span> we append a slice, giving us <code>s3</code> equal to <code>[]int{0, 0, 2, 3, 5, 7, 0, 0}</code>.
Note the three dots used after <code>s0...</code>! This is needed make it clear
  explicit that you&rsquo;re appending another slice, instead of a single value.</p>

<p>The copy function copies slice elements from a source to a destination, and
returns the number of elements it copied. This number is the minimum of the
length of the source and the length of the destination. For example:
<span class="index" id="idxref:55"></span></p>

<pre><code class="language-go">var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
n1 := copy(s, a[0:]) <span class="callout">1</span>
n2 := copy(s, s[2:]) <span class="callout">2</span>
</code></pre>

<p>After <span class="callout">1</span>, <code>n1</code> is 6, and <code>s</code> is <code>[]int{0, 1, 2, 3, 4, 5}</code>.
And after <span class="callout">2</span>, <code>n2</code> is 4, and <code>s</code> is <code>[]int{2, 3, 4, 5, 4, 5}</code>.</p>

<h3 id="maps">Maps</h3>

<p>Many other languages have a type similar to maps built-in. For instance, Perl
has hashes, Python has its dictionaries, and C++ also has maps (as part of the
libraries). In Go we have the <code>map</code> <span class="index" id="idxref:56"></span> type. A <code>map</code> can be
thought of as an array indexed by strings (in its most simple form).</p>

<pre><code class="language-go">monthdays := map[string]int{
    &quot;Jan&quot;: 31, &quot;Feb&quot;: 28, &quot;Mar&quot;: 31,
    &quot;Apr&quot;: 30, &quot;May&quot;: 31, &quot;Jun&quot;: 30,
    &quot;Jul&quot;: 31, &quot;Aug&quot;: 31, &quot;Sep&quot;: 30,
    &quot;Oct&quot;: 31, &quot;Nov&quot;: 30, &quot;Dec&quot;: 31, <span class="callout">1</span>
}
</code></pre>

<p>The general syntax for defining a map is <code>map[&lt;from type&gt;]&lt;to type&gt;</code>. Here, we
define a map that converts from a <code>string</code> (month abbreviation) to an <code>int</code>
(number of days in that month). Note that the trailing comma at <span class="callout">1</span> is
<em>required</em>.</p>

<p>Use <code>make</code> when only declaring a map: <code>monthdays := make(map[string]int)</code>. A map
is a reference type.</p>

<p>For indexing (&ldquo;searching&rdquo;) the map, we use square brackets. For example, suppose
we want to print the number of days in December: <code>fmt.Printf(&quot;%d\n&quot;,
monthdays[&quot;Dec&quot;])</code></p>

<p>If you are looping over an array, slice, string, or map a, <code>range</code> <span class="index" id="idxref:57"></span> clause will help you again, it returns the key and corresponding value
with each invocation.</p>

<pre><code class="language-go">year := 0
for _, days := range monthdays <span class="callout">1</span>
    year += days
}
fmt.Printf(&quot;Numbers of days in a year: %d\n&quot;, year)
</code></pre>

<p>At <span class="callout">1</span> we use the underscore to ignore (assign to nothing) the key returned by
<code>range</code>. We are only interested in the values from <code>monthdays</code>.</p>

<p><span class="index" id="idxref:58"></span></p>

<p>To add elements to the map, you would add new month with: <code>monthdays[&quot;Undecim&quot;]
= 30</code>. If you use a key that already exists, the value will be silently
overwritten: <code>monthdays[&quot;Feb&quot;] = 29</code>. To test for existence <span class="index" id="idxref:59"></span> you would use the following: <code>value, present := monthdays[&quot;Jan&quot;]</code>.
If the key &ldquo;Jan&rdquo; exists, <code>present</code> will be true. It&rsquo;s more Go like to name
<code>present</code> &ldquo;ok&rdquo;, and use: <code>v, ok := monthdays[&quot;Jan&quot;]</code>. In Go we call this the
&ldquo;comma ok&rdquo; form.</p>

<p>You can remove elements <span class="index" id="idxref:60"></span> from the <code>map</code>:
<code>delete(monthdays, &quot;Mar&quot;)</code> <sup class="footnote-ref" id="fnref:Always-rainy-in"><a href="#fn:Always-rainy-in">8</a></sup>. In general the
syntax <code>delete(m, x)</code> will delete the map entry retrieved by the expression
<code>m[x]</code>.</p>

<h2 id="exercises">Exercises</h2>

<h3 id="for-loop" class="exersice" data-difficulty="0">For-loop</h3>

<ol>
<li><p>Create a loop with the <code>for</code> construct. Make it loop
10 times and print out the loop counter with the <code>fmt</code> package.</p></li>

<li><p>Rewrite the loop from 1 to use <code>goto</code>. The keyword <code>for</code> may not be used.</p></li>

<li><p>Rewrite the loop again so that it fills an array and then prints that array to the screen.</p></li>
</ol>

<h3 id="answer" class="answer">Answer</h3>

<ol>
<li>There are many possibilities. One solution could be:</li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(&quot;%d&quot;, i)
	}
}
</code></pre>

<p>Let&rsquo;s compile this and look at the output.</p>

<pre><code>    % go build for.go
    % ./for
    0
    1
    .
    .
    .
    9
</code></pre>

<ol start="2">
<li><p>Rewriting the loop results in code that should look something
like this (only showing the <code>main</code>-function):</p>

<pre><code class="language-go">func main() {
    i := 0	<span class="callout">1</span>
Loop:		    <span class="callout">2</span>
    if i &lt; 10 {
        fmt.Printf(&quot;%d\n&quot;, i)
        i++
        goto Loop <span class="callout">3</span>
    }
}
</code></pre>
<p>At <span class="callout">1</span> we define our loop variable. And at <span class="callout">2</span> we define a label and at <span class="callout">3</span> we jump
to this label.</p></li>

<li><p>The following is one possible solution:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var arr [10]int <span class="callout">1</span>
	for i := 0; i &lt; 10; i++ {
		arr[i] = i <span class="callout">2</span>
	}
	fmt.Printf(&quot;%v&quot;, arr) <span class="callout">3</span>
}
</code></pre>
<p>Here <span class="callout">1</span> we create an array with 10 elements.
Which we then fill <span class="callout">2</span> one by one. And finally we print it <span class="callout">3</span> with <code>%v</code> which lets
Go to print the value for us. You could even do this in one fell swoop by using a composite literal:</p></li>
</ol>

<pre><code class="language-go">fmt.Printf(&quot;%v\n&quot;, [...]int{0,1,2,3,4,5,6,7,8,9})
</code></pre>

<h3 id="average" class="exercise" data-difficulty="1">Average</h3>

<ol>
<li>Write code to calculate the average of a <code>float64</code> slice. In
a later exercise you will make it into a function.</li>
</ol>

<h3 id="answer-1" class="answer">Answer</h3>

<ol>
<li>The following code calculates the average.</li>
</ol>

<pre><code class="language-go">sum := 0.0
switch len(xs) {
case 0: <span class="callout">1</span>
    avg = 0
default: <span class="callout">2</span>
    for _, v := range xs {
        sum += v
    }
    avg = sum / float64(len(xs)) <span class="callout">3</span>
}
</code></pre>

<p>Here at <span class="callout">1</span> we check if the length is zero and if so, we return 0.
Otherwise we calculate the average at <span class="callout">2</span>.
We have to convert the value return from <code>len</code> to a <code>float64</code>
to make the division work at <span class="callout">3</span>.</p>

<h3 id="fizzbuzz" id="ex-fizzbuzz" class="exercise" data-difficulty="0">FizzBuzz</h3>

<ol>
<li>Solve this problem, called the Fizz-Buzz <cite class="informative"><a href="#fizzbuzz"><sup>[fizzbuzz]</sup></a></cite> problem:</li>
</ol>

<p>Write a program that prints the numbers from 1 to 100. But for multiples
of three print, &ldquo;Fizz&rdquo; instead of the number, and for multiples of
five, print &ldquo;Buzz&rdquo;. For numbers which are multiples of both three and
five, print &ldquo;FizzBuzz&rdquo;.</p>

<h3 id="answer-2" class="answer">Answer</h3>

<ol>
<li>A possible solution to this problem is the following program.</li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	const (
		FIZZ = 3 <span class="callout">1</span>
		BUZZ = 5
	)
	var p bool                 <span class="callout">2</span>
	for i := 1; i &lt; 100; i++ { <span class="callout">3</span>
		p = false
		if i%FIZZ == 0 { <span class="callout">4</span>
			fmt.Printf(&quot;Fizz&quot;)
			p = true
		}
		if i%BUZZ == 0 { <span class="callout">5</span>
			fmt.Printf(&quot;Buzz&quot;)
			p = true
		}
		if !p { <span class="callout">6</span>
			fmt.Printf(&quot;%v&quot;, i)
		}
		fmt.Println()
	}
}
</code></pre>

<p>Here <span class="callout">1</span> we define two constants to make our code more readable, see <a href="#constants"></a>.
At <span class="callout">2</span> we define a boolean that keeps track if we already printed something.
At <span class="callout">3</span> we start our for-loop, see <a href="#for"></a>.
If the value is divisible by FIZZ - that is, 3 - , we print &ldquo;Fizz&rdquo; <span class="callout">4</span>.
And at <span class="callout">5</span> we check if the value is divisble by BUZZ &ndash; that is, 5 &ndash; if so print
&ldquo;Buzz&rdquo;. Note that we have also taken care of the FizzBuzz case.
At <span class="callout">6</span>, if printed neither Fizz nor Buzz printed, we print the value.</p>

<h1 id="functions">Functions</h1>
<figure>
<blockquote class="epigraph">
<p>I&rsquo;m always delighted by the light touch and stillness of
early programming languages.  Not much text; a lot gets
done. Old programs read like quiet conversations
between a well-spoken research worker and a well-
studied mechanical colleague, not as a debate with a
compiler.  Who&rsquo;d have guessed sophistication bought
such noise?</p>

<hr>
</blockquote>
<figcaption>Richard P. Gabriel
</figcaption>
</figure>

<p>Functions are the basic building blocks of Go programs; all interesting stuff
happens in them.</p>

<p>Here is an example of how you can declare a function:</p>

<pre><code class="language-go">type mytype int
func (p mytype) funcname(q int) (r,s int) { return 0,0 }
<span class="callout">1</span>        <span class="callout">2</span>        <span class="callout">3</span>      <span class="callout">4</span>        <span class="callout">5</span>         <span class="callout">6</span>
</code></pre>

<p>To declare a function, you use the <code>func</code> keyword <span class="callout">1</span>. You can optionally bind
<span class="callout">2</span> to a specific type called receiver <span class="index" id="idxref:61"></span> (a function
with a receiver is usually called a method<span class="index" id="idxref:62"></span>). This will
be explored in <a href="#interfaces"></a>. Next <span class="callout">3</span> you write the name of your
function. Here <span class="callout">4</span> we define that the variable <code>q</code> of type <code>int</code> is the input
parameter. Parameters are passed <em>pass-by-value</em>.<span class="index" id="idxref:63"></span>
The variables <code>r</code> and <code>s</code> <span class="callout">5</span> are the <em>named return parameters</em> (((functions,
named return parameters))) for this function. Functions in Go can have multiple
return values. This is very useful to return a value <em>and</em> error. This
removes the need for in-band error returns (such as -1 for <code>EOF</code>) and modifying
an argument. If you want the return parameters not to be named you only give the
types: <code>(int, int)</code>. If you have only one value to return you may omit the
parentheses. If your function is a subroutine and does not have anything to
return you may omit this entirely. Finally, we have the body <span class="callout">6</span> of the
function. Note that <code>return</code> is a statement so the braces around the
parameter(s) are optional.</p>

<p>As said the return or result parameters of a Go function can be given names and
used as regular variables, just like the incoming parameters. When named, they
are initialized to the zero values for their types when the function begins. If
the function executes a <code>return</code> statement with no arguments, the current values
of the result parameters are returned. Using these features enables you (again)
to do more with less code.<sup class="footnote-ref" id="fnref:This-is-a-motto"><a href="#fn:This-is-a-motto">9</a></sup></p>

<p>The names are not mandatory but they can make code shorter and clearer:
<em>they are documentation</em>. However don&rsquo;t overuse this feature, especially in
 longer functions where it might not be immediately apparent what is returned.</p>

<p>Functions can be declared in any order you wish. The compiler scans the entire
file before execution, so function prototyping is a thing of the past in Go. Go
does not allow nested functions, but you can work around this with anonymous
functions. See the Section <a href="#functions-as-values"></a> in this chapter. Recursive
functions work just as in other languages:</p>

<pre><code class="language-go">func rec(i int) {
    if i == 10 { <span class="callout">1</span>
        return
    }
    rec(i+1) <span class="callout">2</span>
    fmt.Printf(&quot;%d &quot;, i)
}
</code></pre>

<p>Here <span class="callout">2</span> we call the same function again, <code>rec</code> returns when <code>i</code> has the value
10, this is checked on the second line <span class="callout">1</span>. This function prints: <code>9
8 7 6 5 4 3 2 1 0</code>, when called as <code>rec(0)</code>.</p>

<h2 id="scope">Scope</h2>

<p>Variables declared outside any functions are <em>global</em> <span class="index" id="idxref:64"></span> in Go,
those defined in functions are <em>local</em> <span class="index" id="idxref:65"></span> to those functions. If
names overlap - a local variable is declared with the same name as a global one
- the local variable hides the global one when the current function is executed.</p>

<p>In the following example we call <code>g()</code> from <code>f()</code>:</p>

<pre><code class="language-go">package main

var a int <span class="callout">1</span>

func main() {
    a = 5
    print(a)
    f()
}

func f() {
    a := 6 <span class="callout">2</span>
    print(a)
    g()
}

func g() {
    print(a)
}
</code></pre>

<p>Here <span class="callout">1</span>, we declare <code>a</code> to be a global variable of type <code>int</code>. Then in the
<code>main</code> function we give the <em>global</em> <code>a</code> the value of 5, after printing it we
call the function <code>f</code>. Then here <span class="callout">2</span>, <code>a := 6</code>, we create a <em>new, local</em>
variable also called <code>a</code>. This new <code>a</code> gets the value of 6, which we then print.
Then we call <code>g</code>, which uses the <em>global</em> <code>a</code> again and prints <code>a</code>&rsquo;s value set
in <code>main</code>. Thus the output will be: <code>565</code>. A <em>local</em> variable is <em>only</em> valid
when we are executing the function in which it is defined. Note that the <code>:=</code>
used in line 12 is sometimes hard to spot so it is generally advised <em>not</em> to
use the same name for global and local variables.</p>

<h2 id="functions-as-values">Functions as values</h2>

<p><span class="index" id="idxref:66"></span> <span class="index" id="idxref:67"></span> As with almost everything in
Go, functions are also <em>just</em> values. They can be assigned to variables as
follows:</p>

<pre><code class="language-go">import &quot;fmt&quot;

func main() {
	a := func() { <span class="callout">1</span>
		fmt.Println(&quot;Hello&quot;)
	} <span class="callout">2</span>
	a() <span class="callout">3</span>
}
</code></pre>

<p><code>a</code> is defined as an anonymous (nameless) function <span class="callout">1</span>.
Note the lack of parentheses <code>()</code> after <code>a</code>. If there were, that would be to <em>call</em>
some function with the name <code>a</code> before we have defined what <code>a</code> is. Once <code>a</code> is
defined, then we can <em>call</em> it, <span class="callout">3</span>.</p>

<p>Functions&ndash;as&ndash;values may be used in other places, for example maps. Here we
convert from integers to functions:</p>

<pre><code class="language-go">var xs = map[int]func() int{
    1: func() int { return 10 },
    2: func() int { return 20 },
    3: func() int { return 30 },
}
</code></pre>

<p>Note that the final comma on second to last line is <em>mandatory</em>.</p>

<p>Or you can write a function that takes a function as its parameter, for example
a <code>Map</code> function that works on <code>int</code> slices. This is left as an exercise for the
reader; see the exercise <a href="#map-function"></a>.</p>

<h2 id="callbacks">Callbacks</h2>

<p>Because functions are values they are easy to pass to functions, from where they
can be used as callbacks. First define a function that does &ldquo;something&rdquo; with an
integer value:</p>

<pre><code class="language-go">func printit(x int) {
    fmt.Printf(&quot;%v\n&quot;, x)
}
</code></pre>

<p>This function does not return a value and just prints its argument. The
<em>signature</em> <span class="index" id="idxref:68"></span> of this function is: <code>func printit(int)</code>,
or without the function name: <code>func(int)</code>. To create a new function that uses
this one as a callback we need to use this signature:</p>

<pre><code class="language-go">func callback(y int, f func(int)) {
    f(y)
}
</code></pre>

<p>Here we create a new function that takes two parameters: <code>y int</code>, i.e. just an
<code>int</code> and <code>f func(int)</code>, i.e. a function that takes an int and returns nothing.
The parameter <code>f</code> is the variable holding that function. It can be used as any
other function, and we execute the function on line 2 with the parameter <code>y</code>:
<code>f(y)</code></p>

<h2 id="deferred-code">Deferred Code</h2>

<p>Suppose you have a function in which you open a file and perform various writes
and reads on it. In such a function there are often spots where you want to
return early. If you do that, you will need to close the file descriptor you are
working on. This often leads to the following code:</p>

<pre><code class="language-go">func ReadWrite() bool {
    file.Open(&quot;file&quot;)
    // Do your thing
    if failureX {
        file.Close() <span class="callout">1</span>
        return false
    }

    if failureY {
        file.Close() <span class="callout">1</span>
        return false
    }
    file.Close() <span class="callout">1</span>
    return true  <span class="callout">2</span>
}
</code></pre>

<p>Note that we repeat a lot of code here; you can see the that <code>file.Close()</code> is
called at <span class="callout">1</span>. To overcome this, Go has the <code>defer</code> <span class="index" id="idxref:69"></span>
keyword. After <code>defer</code> you specify a function which is called just <em>before</em> <span class="callout">2</span>
the current function exits.</p>

<p>With <code>defer</code> we can rewrite the above code as follows. It makes the function
more readable and it puts the <code>Close</code> <em>right next</em> to the <code>Open</code>.</p>

<pre><code class="language-go">func ReadWrite() bool {
    file.Open(&quot;filename&quot;)
    defer file.Close() <span class="callout">1</span>
    // Do your thing
    if failureX {
        return false <span class="callout">2</span>
    }
    if failureY {
        return false <span class="callout">2</span>
    }
    return true <span class="callout">2</span>
}
</code></pre>

<p>At <span class="callout">1</span> <code>file.Close()</code> is added to the defer list. <span class="index" id="idxref:70"></span>
<code>Close</code> is now done automatically at <span class="callout">2</span>. This makes the function shorter and
more readable. It puts the <code>Close</code> right next to the <code>Open</code>.</p>

<p>You can put multiple functions on the &ldquo;defer list&rdquo;, like this example from</p>

<pre><code class="language-go">for i := 0; i &lt; 5; i++ {
    defer fmt.Printf(&quot;%d &quot;, i)
}
</code></pre>

<p>Deferred functions are executed in LIFO order, so the above code prints: <code>4
3 2 1 0</code>.</p>

<p>With <code>defer</code> you can even change return values, provided that you are using
named result parameters and a function literal <span class="index" id="idxref:71"></span><sup class="footnote-ref" id="fnref:A-function-liter"><a href="#fn:A-function-liter">10</a></sup>, i.e:</p>

<pre><code class="language-go">defer func() {/* ... */}()
</code></pre>

<p>Here we use a function without a name and specify the body of the function
inline, basically we&rsquo;re creating a nameless function on the spot. The final
parentheses are needed because <code>defer</code> needs a function call, not a function value.
If our anonymous function would take an parameter it would be easier to see why
we need the parentheses:</p>

<pre><code class="language-go">defer func(x int) {/* ... */}(5)
</code></pre>

<p>In this (unnamed) function you can access any named return parameter:</p>

<pre><code class="language-go">func f() (ret int)
    defer func() { <span class="callout">1</span>
        ret++
    }()
    return 0
}
</code></pre>

<p>Here <span class="callout">1</span> we specify our function, the named return value <code>ret</code> is initialized
with zero. The nameless function in the defer increments the value of <code>ret</code>
with 1. The <code>return 0</code> on line
5 <em>will not be the returned value</em>, because of <code>defer</code>. The function <code>f</code> will
return 1!</p>

<h2 id="variadic-parameter">Variadic Parameter</h2>

<p>Functions that take a variable number of parameters are known as variadic
functions. <span class="index" id="idxref:72"></span> To declare a function as variadic, do
something like this:</p>

<pre><code class="language-go">func myfunc(arg ...int) {}
</code></pre>

<p>The <code>arg ...int</code> instructs Go to see this as a function that takes a variable
number of arguments. Note that these arguments all have to have the type <code>int</code>.
In the body of your function the variable <code>arg</code> is a slice of ints:</p>

<pre><code class="language-go">for _, n := range arg {
    fmt.Printf(&quot;And the number is: %d\n&quot;, n)
}
</code></pre>

<p>We range over the arguments on the first line. We are not interested in the
index as returned by <code>range</code>, hence the use of the underscore there. In the body
of the <code>range</code> we just print the parameters we were given.</p>

<p>If you don&rsquo;t specify the type of the variadic argument it defaults to the empty
interface <code>interface{}</code> (see Chapter <a href="#interfaces"></a>).</p>

<p>Suppose we have another variadic function called <code>myfunc2</code>, the following
example shows how to pass variadic arguments to it:</p>

<pre><code class="language-go">func myfunc(arg ...int) {
    myfunc2(arg...)
    myfunc2(arg[:2]...)
}
</code></pre>

<p>With <code>myfunc2(arg...)</code> we pass all the parameters to <code>myfunc2</code>, but because the
variadic parameters is just a slice, we can use some slice tricks as well.</p>

<h2 id="panic-and-recovering">Panic and recovering</h2>

<p>Go does not have an exception mechanism: you cannot throw exceptions. Instead it
uses a panic-and-recover mechanism. It is worth remembering that you should use
this as a last resort, your code will not look, or be, better if it is littered
with panics. It&rsquo;s a powerful tool: use it wisely. So, how do you use it? In the
words of the Go Authors <cite class="informative"><a href="#go_blog_panic"><sup>[go_blog_panic]</sup></a></cite>:</p>

<dl>
<dt>Panic</dt>
<dd>is a built-in function that stops the ordinary flow of control and begins
panicking. When the function <code>F</code> calls <code>panic</code>, execution of <code>F</code> stops, any
deferred functions in <code>F</code> are executed normally, and then <code>F</code> returns to its
caller. To the caller, <code>F</code> then behaves like a call to <code>panic</code>. The process
continues up the stack until all functions in the current goroutine have
returned, at which point the program crashes. Panics can be initiated by
invoking <code>panic</code> directly. They can also be caused by <em>runtime errors</em>, such as
out-of-bounds array accesses.</dd>
<dt>Recover</dt>
<dd>is a built-in function that regains control of a panicking goroutine.
Recover is <em>only</em> useful inside <em>deferred</em> functions. During normal execution,
a call to <code>recover</code> will return <code>nil</code> and have no other effect. If the current
goroutine is panicking, a call to <code>recover</code> will capture the value given to
<code>panic</code> and resume normal execution.</dd>
</dl>

<p>This function checks if the function it gets as argument will panic when it is
executed<sup class="footnote-ref" id="fnref:Modified-from-a"><a href="#fn:Modified-from-a">11</a></sup>:</p>

<pre><code class="language-go">func Panic(f func()) (b bool) { <span class="callout">1</span>
    defer func() { <span class="callout">2</span>
        if x := recover(); x != nil {
            b = true
        }
    }()
    f() <span class="callout">3</span>
    return <span class="callout">4</span>
}
</code></pre>

<p>We define a new function <code>Panic</code> <span class="callout">1</span> that takes a function as an argument (see
<a href="#functions-as-values"></a>). It returns true if <code>f</code> panics when run, else false. We
then <span class="callout">2</span> define a <code>defer</code> function that utilizes <code>recover</code>. If the current
goroutine panics, this defer function will notice that. If <code>recover()</code> returns
non-<code>nil</code> we set <code>b</code> to true. At <span class="callout">3</span> Execute the function we received as the
argument. And finally <span class="callout">4</span> we return the value of <code>b</code>. Because <code>b</code> is a named
return parameter.</p>

<p>The following code fragment, shows how we can use this function:</p>

<pre><code class="language-go">func panicy() {
    var a []int
    a[3] = 5
}

func main() {
    fmt.Println(Panic(panicy))
}
</code></pre>

<p>On line 3 the <code>a[3] = 5</code> triggers a <em>runtime</em> out of bounds error which results
in a panic. Thus this program will print <code>true</code>. If we change line 2: <code>var
a []int</code> to <code>var a [4]int</code> the function <code>panicy</code> does not panic anymore. Why?</p>

<h2 id="exercises-1">Exercises</h2>

<h3 id="average-1" class="exercise" data-difficulty="0">Average</h3>

<ol>
<li>Write a function that calculates the average of a <code>float64</code> slice.</li>
</ol>

<h3 id="answer-3" class="answer">Answer</h3>

<ol>
<li>The following function calculates the average:</li>
</ol>

<pre><code class="language-go">package main

func average(xs []float64) (avg float64) { //&lt;1&gt;
	sum := 0.0
	switch len(xs) {
	case 0:                 //&lt;2&gt;
		avg = 0
	default:                //&lt;3&gt;
		for _, v := range xs {
			sum += v
		}
		avg = sum / float64(len(xs)) //&lt;4&gt;
	}
	return  //&lt;5&gt;
}
</code></pre>

<p>At <span class="callout">1</span> we use a named return parameter.  If the length of <code>xs</code> is zero <span class="callout">2</span>, we
 return 0.  Otherwise <span class="callout">3</span>, we calculate the average.  At <span class="callout">4</span>  we convert the
 value to a <code>float64</code> to make the division work as <code>len</code> returns an <code>int</code>.
 Finally, at <span class="callout">5</span> we reutrn our avarage.</p>

<h3 id="bubble-sort" class="exercise" data-difficulty="1">Bubble sort</h3>

<ol>
<li>Write a function that performs a bubble sort on a slice of ints. From <cite class="informative"><a href="#bubblesort"><sup>[bubblesort]</sup></a></cite>:</li>
</ol>

<blockquote>
<p>It works by repeatedly stepping through the list to be sorted, comparing each
pair of adjacent items and swapping them if they are in the wrong order. The
pass through the list is repeated until no swaps are needed, which indicates
that the list is sorted. The algorithm gets its name from the way smaller
elements &ldquo;bubble&rdquo; to the top of the list.</p>
</blockquote>

<p>It also gives an example in pseudo code:</p>

<pre><code>procedure bubbleSort( A : list of sortable items )
  do
    swapped = false
    for each i in 1 to length(A) - 1 inclusive do:
      if A[i-1] &gt; A[i] then
        swap( A[i-1], A[i] )
        swapped = true
      end if
    end for
  while swapped
end procedure
</code></pre>

<h3 id="answer-4">Answer</h3>

<ol>
<li><p>Bubble sort isn&rsquo;t terribly efficient. For <span class="math inline">\(n\)</span> elements it scales <span class="math inline">\(O(n^2)\)</span>.
But bubble sort is easy to implement:</p>

<pre><code class="language-go">
func main() {
	n := []int{5, -1, 0, 12, 3, 5}
	fmt.Printf(&quot;unsorted %v\n&quot;, n)
	bubblesort(n)
	fmt.Printf(&quot;sorted %v\n&quot;, n)
}

func bubblesort(n []int) {
	for i := 0; i &lt; len(n)-1; i++ {
		for j := i + 1; j &lt; len(n); j++ {
			if n[j] &lt; n[i] {
				n[i], n[j] = n[j], n[i]
			}
</code></pre>
<p>Because a slice is a reference type, the <code>bubblesort</code> function works and
does not need to return a sorted slice.</p></li>
</ol>

<h3 id="for-loop-ii" class="exercise" data-difficulty="0">For-loop II</h3>

<ol>
<li>Take what you did in exercise to write the for loop and extend it a bit.
Put the body of the for loop - the <code>fmt.Printf</code> - in a separate function.</li>
</ol>

<h3 id="answer-5" class="answer">Answer</h3>

<ol>
<li>
<!-- comment -->

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	for i := 0; i &lt; 10; i++ {
		show(i)
	}
}

func show(j int) {
	fmt.Printf(&quot;%d\n&quot;, j)
}
</code></pre></li>
</ol>

<h3 id="fibonacci" class="exercise" data-difficulty="1">Fibonacci</h3>

<ol>
<li><p>The Fibonacci sequence starts as follows: <span class="math inline">\(1, 1, 2, 3, 5, 8, 13, \ldots\)</span>
Or in mathematical terms: <span class="math inline">\(x_1 = 1; x_2 = 1; x_n = x_{n-1} + x_{n-2}\quad\forall n &gt; 2\)</span>.</p>

<p>Write a function that takes an <code>int</code> value and gives
that many terms of the Fibonacci sequence.</p></li>
</ol>

<h3 id="answer-6" class="answer">Answer</h3>

<ol>
<li>The following program calculates Fibonacci numbers:</li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func fibonacci(value int) []int {
	x := make([]int, value) <span class="callout">1</span>
	x[0], x[1] = 1, 1       <span class="callout">2</span>
	for n := 2; n &lt; value; n++ {
		x[n] = x[n-1] + x[n-2] <span class="callout">3</span>
	}
	return x <span class="callout">4</span>
}

func main() {
	for _, term := range fibonacci(10) { <span class="callout">5</span>
		fmt.Printf(&quot;%v &quot;, term)
	}
}
</code></pre>

<p>At <span class="callout">1</span> we create an array to hold the integers up to the value given in
the function call.  At <span class="callout">2</span> we start the Fibonacci calculation. Then <span class="callout">3</span>:
<span class="math inline">\(x_n = x_{n-1} + x_{n-2}\)</span>.  At <span class="callout">4</span> we return the <em>entire</em> array.
And at <span class="callout">5</span> we use the <code>range</code> keyword to  &ldquo;walk&rdquo; the numbers returned by the
Fibonacci function. Here up to 10. Finally, we print the numbers.</p>

<h3 id="var-args" class="exercise" data-difficulty="1">Var args</h3>

<ol>
<li>Write a function that takes a variable number of ints and print each integer on a separate line.</li>
</ol>

<h3 id="answer-7">Answer</h3>

<ol>
<li><p>For this we need the <code>{...}</code>-syntax to signal we define a
function that takes an arbitrary number of arguments.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	printthem(1, 4, 5, 7, 4)
	printthem(1, 2, 4)
}

func printthem(numbers ...int) {
	for _, d := range numbers {
		fmt.Printf(&quot;%d\n&quot;, d)
	}
}
</code></pre></li>
</ol>

<h3 id="functions-that-return-functions" class="exercise" data-difficulty="1">Functions that return functions</h3>

<ol>
<li><p>Write a function that returns a function that performs a <span class="math inline">\(+2\)</span> on integers. Name the function <code>plusTwo</code>.
You should then be able do the following:</p>

<pre><code class="language-go">p := plusTwo()
fmt.Printf(&quot;%v\n&quot;, p(2))
</code></pre>
<p>Which should print 4. See <a href="#callbacks"></a>.</p></li>

<li><p>Generalize the function from above and create a <code>plusX(x)</code> which returns functions that add <code>x</code> to an integer.</p></li>
</ol>

<h3 id="answer-8" class="answer">Answer</h3>

<ol>
<li><p>Define a new function that returns a function: <code>return func(x int) int { return x + 2 }</code>
Function literals at work, we define the +2&ndash;function right there in the return statement.</p>

<pre><code class="language-go">func main() {
   p2 := plusTwo()
   fmt.Printf(&quot;%v\n&quot;,p2(2))
}


func plusTwo() func(int) int { <span class="callout">1</span>
    return func(x int) int { return x + 2 } <span class="callout">2</span>
}
</code></pre></li>

<li><p>Here we use a closure:</p>

<pre><code class="language-go">func plusX(x int) func(int) int { <span class="callout">1</span>
   return func(y int) int { return x + y } <span class="callout">2</span>
}
</code></pre>
<p>Here <span class="callout">1</span>, we again define a function that returns a function.
We use the <em>local</em> variable <code>x</code> in the function literal at <span class="callout">2</span>.</p></li>
</ol>

<h3 id="maximum" class="exercise" data-difficulty="0">Maximum</h3>

<ol>
<li>Write a function that finds the
maximum value in an <code>int</code> slice (<code>[]int</code>).</li>
</ol>

<h3 id="answer-9" class="answer">Answer</h3>

<ol>
<li><p>This function returns the largest int in the slice \var{l}:</p>

<pre><code class="language-go">func max(l []int) (max int) {   <span class="callout">1</span>
    max = l[0]
    for _, v := range l {   <span class="callout">2</span>
        if v &gt; max {    <span class="callout">3</span>
            max = v
        }
    }
    return <span class="callout">4</span>
}
</code></pre>
<p>At <span class="callout">1</span> we use a named return parameter.
At <span class="callout">2</span> we loop over <code>l</code>. The index of the element is not important.
At <span class="callout">3</span>, if we find a new maximum, we remember it.
And at <span class="callout">4</span> we have a &ldquo;lone&rdquo; return; the current value of <code>max</code> is now returned.</p></li>
</ol>

<h3 id="map-function" class="exercise" data-difficulty="1">Map function</h3>

<p>A <code>map()</code>-function is a function that takes
a function and a list. The function is applied to
each member in the list and a new list containing
these calculated values is returned.
Thus:</p>

<p><span class="math inline">\( \mathrm{map}(f(), (a_1,a_2,\ldots,a_{n-1},a_n)) =  (f(a_1), f(a_2),\ldots,f(a_{n-1}), f(a_n)) \)</span></p>

<ol>
<li>Write a simple
<code>map()</code>-function in Go. It is sufficient for this function only to work for ints.</li>
</ol>

<h3 id="answer-10" class="answer">Answer</h3>

<ol>
<li><p>A possible answer:</p>

<pre><code class="language-go">func Map(f func(int) int, l []int) []int {
    j := make([]int, len(l))
    for k, v := range l {
        j[k] = f(v)
    }
    return j
}


func main() {
    m := []int{1, 3, 4}
    f := func(i int) int {
        return i * i
    }
    fmt.Printf(&quot;%v&quot;, (Map(f, m)))
}
</code></pre></li>
</ol>

<h3 id="stack" class="exercise" data-difficulty="1">Stack</h3>

<ol>
<li>Create a simple stack which can hold a
fixed number of ints. It does not have to grow beyond this limit.
Define <code>push</code> &ndash; put something on the stack &ndash; and <code>pop</code>
&ndash; retrieve something from the stack &ndash; functions. The stack should be
a LIFO (last in, first out) stack.</li>
</ol>
<figure><p><img src="fig/stack.png" alt="A stack" /></p>
<figcaption>A stack.
</figcaption>
</figure>

<ol start="2">
<li>Write a <code>String</code> method which
converts the stack to a string representation.
The stack in the figure could be represented as: <code>[0:m] [1:l] [2:k]</code> .</li>
</ol>

<h3 id="answer-11" class="answer">Answer</h3>

<ol>
<li><p>First we define a new type that represents a stack; we need an
array (to hold the keys) and an index, which points to the last element.
Our small stack can only hold 10 elements.</p>

<pre><code class="language-go">type stack struct {
    i    int
    data [10]int
}
</code></pre></li>
</ol>

<p>Next we need the <code>push</code> and <code>pop</code> functions to actually
use the thing. First we show the <em>wrong</em> solution!</p>

<p>In Go, data passed to functions is <em>passed-by-value</em> meaning a copy
is created and given to the function. The first stab for the function
<code>push</code> could be:</p>

<pre><code class="language-go">func (s stack) push(k int) {
    if s.i+1 &gt; 9 {
            return
    }
    s.data[s.i] = k
    s.i++
}
</code></pre>

<p>The function works on the <code>s</code> which is of the type <code>stack</code>. To
use this we just call <code>s.push(50)</code>, to push the integer 50 on
the stack. But the push function gets a copy of <code>s</code>, so it is
<em>not</em> working on the <em>real</em> thing. Nothing gets pushed to our
stack. For example the following code:</p>

<pre><code class="language-go">var s stack
s.push(25)
fmt.Printf(&quot;stack %v\n&quot;, s);
s.push(14)
fmt.Printf(&quot;stack %v\n&quot;, s);
</code></pre>

<p>prints:</p>

<pre><code>stack [0:0]
stack [0:0]
</code></pre>

<p>To solve this we need to give the function <code>push</code> a pointer
to the stack. This means we need to change <code>push</code> from</p>

<pre><code class="language-go">func (s stack) push(k int)
</code></pre>

<p>to</p>

<pre><code class="language-go">func (s *stack) push(k int).
</code></pre>

<p>We should now use <code>new()</code> (see <a href="#allocation-with-new"></a>).
in <a href="#beyond-the-basics"></a> to create a <em>pointer</em> to a newly
allocated <code>stack</code>, so line 1 from the example above needs to be
<code>s := new(stack)</code> .</p>

<p>And our two functions become:</p>

<pre><code class="language-go">func (s *stack) push(k int) {
    s.data[s.i] = k
    s.i++
}

func (s *stack) pop() int {
    s.i--
    ret := s.data[s.i]
    s.data[s.i] = 0
    return ret
}
</code></pre>

<p>Which we then use as follows:</p>

<pre><code class="language-go">func main() {
    var s stack
    s.push(25)
    s.push(14)
    fmt.Printf(&quot;stack %v\n&quot;, s)
}
</code></pre>

<ol start="2">
<li><p><code>fmt.Printf(&quot;%v&quot;)</code> can
print any value (<code>%v</code>) that satisfies the <code>Stringer</code> interface
(see <a href="#interfaces"></a>).
For this to work we only need to define a <code>String()</code> function for
our type:</p>

<pre><code class="language-go">func (s stack) String() string {
    var str string
    for i := 0; i &lt;= s.i; i++ {
        str = str + &quot;[&quot; +
            strconv.Itoa(i) + &quot;:&quot; + strconv.Itoa(s.data[i]) + &quot;]&quot;
    }
    return str
}
</code></pre></li>
</ol>

<h1 id="packages">Packages</h1>
<figure>
<blockquote class="epigraph">
<p>&ldquo;^&rdquo;</p>

<hr>
</blockquote>
<figcaption>Answer to whether there is a bit wise negation operator &ndash; Ken Thompson
</figcaption>
</figure>

<p>A package <span class="index" id="idxref:73"></span> is a collection of functions and data.</p>

<p>You declare a package with the <code>package</code><span class="index" id="idxref:74"></span> keyword. The
filename does not have to match the package name. The convention for package
names is to use lowercase characters. Go packages may consist of multiple files,
but they share the <code>package &lt;name&gt;</code> line. Let&rsquo;s define a package <code>even</code> in the
file <code>even.go</code>.</p>

<p><span class="index" id="idxref:75"></span>
<span class="index" id="idxref:76"></span>
<span class="index" id="idxref:77"></span></p>

<pre><code class="language-go">package even <span class="callout">1</span>

func Even(i int) bool { <span class="callout">2</span>
	return i%2 == 0
}

func odd(i int) bool { <span class="callout">3</span>
	return i%2 == 1
}
</code></pre>

<p>Here <span class="callout">1</span> we start a new namespace: &ldquo;even&rdquo;. The function <code>Even</code> <span class="callout">2</span> starts with
a capital letter. This means the function is <em>exported</em>, and may be used outside
our package (more on that later). The function <code>odd</code> <span class="callout">3</span> does not start with
a capital letter, so it is a <em>private</em> function.</p>

<p>Now we just need to build the package. We create a directory under <code>$GOPATH</code>,
and copy <code>even.go</code> there (see <a href="#compiling-and-running-code"></a> in <a href="#basics"></a>).</p>

<pre><code>% mkdir $GOPATH/src/even
% cp even.go $GOPATH/src/even
% go build
% go install
</code></pre>

<p>Now we can use the package in our own program <code>myeven.go</code>:</p>

<pre><code class="language-go">package main

import ( <span class="callout">1</span>
	&quot;even&quot; <span class="callout">2</span>
	&quot;fmt&quot;  <span class="callout">3</span>
)

func main() {
	i := 5
	fmt.Printf(&quot;Is %d even? %v\n&quot;, i, even.Even(i)) <span class="callout">4</span>
}
</code></pre>

<p>Import <span class="callout">1</span> the following packages. The <em>local</em> package <code>even</code> is imported here
<span class="callout">2</span>. This <span class="callout">3</span> imports the official <code>fmt</code> package. And now we use <span class="callout">4</span> the
function from the <code>even</code> package. The syntax for accessing a function from
a package is <code>&lt;package&gt;.FunctionName()</code>. And finally we can build our program.</p>

<pre><code>% go build myeven.go
% ./myeven
Is 5 even? false
</code></pre>

<p>If we change our <code>myeven.go</code> at <span class="callout">4</span> to use the unexported function <code>even.odd</code>:
<code>fmt.Printf(&quot;Is %d even? %v\n&quot;, i, even.odd(i))</code> We get an error when compiling,
because we are trying to use a
<em>private</em> function:</p>

<pre><code>myeven.go: cannot refer to unexported name even.odd
</code></pre>

<p>Note that the &ldquo;starts with capital <span class="math inline">\(\rightarrow\)</span> exported&rdquo;, &ldquo;starts with
lower-case <span class="math inline">\(\rightarrow\)</span> private&rdquo; rule also extends to other names (new
types, global variables) defined in the package. Note that the term &ldquo;capital&rdquo; is
not limited to US-ASCII &ndash; it extends to all bicameral alphabets (Latin, Greek,
Cyrillic, Armenian and Coptic).</p>

<h2 id="identifiers">Identifiers</h2>

<p>The Go standard library names some function with the old (Unix) names while
others are in CamelCase. The convention is to leave well-known legacy
not-quite-words alone rather than try to figure out where the capital letters
go:  <code>Atoi</code>, <code>Getwd</code>, <code>Chmod</code>. CamelCasing works best when you have whole words
to work with: <code>ReadFile</code>, <code>NewWriter</code>, <code>MakeSlice</code>. The convention in Go is to
use CamelCase rather than underscores to write multi-word names.</p>

<p>As we did above in our <code>myeven</code> program, accessing content from an imported
(with <code>import</code> <span class="index" id="idxref:78"></span>) package is done with using the package&rsquo;s
name and then a dot.  After <span class="index" id="idxref:79"></span> <code>import &quot;bytes&quot;</code> the importing
program can talk about <code>bytes.Buffer</code>. A package name should be good, short,
concise and evocative. The convention in Go is that package names are lowercase,
single word names.</p>

<p>The package name used in the <code>import</code> statement is the default name used. But if
the need arises (two different packages with the same name for instance), you
can override this default: <code>import bar &quot;bytes&quot;</code> The function <code>Buffer</code> is now
accessed as <code>bar.Buffer</code>.</p>

<p>Another convention is that the package name is the base name of its source
directory; the package in <code>src/compress/gzip</code> is imported as <code>compress/gzip</code> but
has name <code>gzip</code>, not <code>compress/gzip</code>.</p>

<p>It is important to avoid stuttering when naming things. For instance, the
buffered reader type in the <code>bufio</code> <span class="index" id="idxref:80"></span> package is called
<code>Reader</code>, not <code>BufReader</code>, because users see it as <code>bufio.Reader</code>, which is
a clear, concise name.</p>

<p>Similarly, the function to make new instances of <code>ring.Ring</code> (package
<code>container/ring</code>), would normally be called <code>NewRing</code>, but since <code>Ring</code> is the
only type exported by the package, and since the package is called
<code>ring</code><span class="index" id="idxref:81"></span>, it&rsquo;s called just <code>New</code>. Clients of the package see
that as <code>ring.New</code>. Use the package structure to help you choose good names.</p>

<p>Another short example is <code>once.Do</code> (see package <code>sync</code>); <code>once.Do(setup)</code> reads
well and would not be improved by writing <code>once.DoOrWaitUntilDone(setup)</code>. Long
names don&rsquo;t automatically make things more readable.</p>

<h2 id="documenting-packages">Documenting packages</h2>

<p>When we created our <code>even</code> package, we skipped over an important item:
documentation. Each package should have a <em>package comment</em>, a block comment
preceding the <code>package</code> clause. In our case we should extend the beginning of
the package, with:</p>

<pre><code class="language-go">// The even package implements a fast function for detecting if an integer
// is even or not.
package even
</code></pre>

<p>When running <code>go doc</code> this will show up at the top of the page. When a package
consists of multiple files the package comment should only appear in one
file. A common convention (in really big packages) is to have a separate
<code>doc.go</code> that only holds the package comment. Here is a snippet from the
official <code>regexp</code> package:</p>

<pre><code class="language-go">/*
    The regexp package implements a simple library for
    regular expressions.

    The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
*/
package regexp
</code></pre>

<p>Each defined (and exported) function should have a small line of text
documenting the behavior of the function. Again to extend our <code>even</code> package:</p>

<pre><code class="language-go">// Even returns true of i is even. Otherwise false is returned.
func Even(i int) bool {
</code></pre>

<p>And even though <code>odd</code> is not exported, it&rsquo;s good form to document it as well.</p>

<pre><code class="language-go">// odd is the opposite of Even.
func odd(i int) bool {
</code></pre>

<h2 id="testing-packages">Testing packages</h2>

<p>In Go it is customary to write (unit) tests for your package. Writing tests
involves the <code>testing</code> package and the program <code>go test</code><span class="index" id="idxref:82"></span>.
Both have excellent documentation.</p>

<p>The <code>go test</code> program runs all the test functions. Without any defined tests for
our <code>even</code> package, <code>go test</code> yields:</p>

<pre><code>% go test
?       even    [no test files]
</code></pre>

<p>Let us fix this by defining a test in a test file. Test files reside in the
package directory and are named <code>*_test.go</code>. Those test files are just like
other Go programs, but <code>go test</code> will only execute the test functions. Each test
function has the same signature and its name should start with
<code>Test</code>: <code>func TestXxx(t *testing.T)</code> .</p>

<p>When writing test you will need to tell <code>go test</code> whether a test was
successful or not. A successful test function just returns. When
the test fails you can signal this with the following
functions. These are the most important ones (see <code>go doc testing</code> or <code>go help testfunc</code> for more):</p>

<ul>
<li><p><code>func (t *T) Fail()</code>, <code>Fail</code> marks the test function as having failed but
continues execution.</p></li>

<li><p><code>func (t *T) FailNow()</code>, <code>FailNow</code> marks the test function as having failed
and stops its execution. Any remaining tests in this file are skipped, and
execution continues with the next test.</p></li>

<li><p><code>func (t *T) Log(args ...interface{})</code>, <code>Log</code> formats its arguments using
default formatting, analogous to <code>Print()</code>, and records the text in the error
log.</p></li>

<li><p><code>func (t *T) Fatal(args ...interface{})</code>, <code>Fatal</code> is equivalent to <code>Log()</code>
followed by <code>FailNow()</code>.</p></li>
</ul>

<p>Putting all this together we can write our test. First we pick a name:
<code>even_test.go</code>. Then we add the following contents:</p>

<pre><code class="language-go">package even <span class="callout">1</span>

import &quot;testing&quot; <span class="callout">2</span>

func TestEven(t *testing.T) { <span class="callout">3</span>
	if !Even(2) {
		t.Log(&quot;2 should be even!&quot;)
		t.Fail()
	}
}
</code></pre>

<p>A test file belongs to the current <span class="callout">1</span> package. This is not only convenient, but
also allows tests of unexported functions and structures. We then <span class="callout">2</span> import the
<code>testing</code> package. And finally the test we want to execute. The code here <span class="callout">3</span>
should hold no surprises: we check if the <code>Even</code> function works OK. And now, the
moment we have been waiting for executing the test.</p>

<pre><code>% go test
ok      even    0.001s
</code></pre>

<p>Our test ran and reported <code>ok</code>. Success! If we redefine our test function, we
can see the result of a failed test:</p>

<pre><code class="language-go">// Entering the twilight zone
func TestEven(t *testing.T) {
    if Even(2) {
        t.Log(&quot;2 should be odd!&quot;)
        t.Fail()
    }
}
</code></pre>

<p>We now get:</p>

<pre><code>FAIL    even    0.004s
--- FAIL: TestEven (0.00 seconds)
    2 should be odd!
FAIL
</code></pre>

<p>And you can act accordingly (by fixing the test for instance).</p>

<p>Writing new packages should go hand in hand with writing (some)
documentation and test functions. It will make your code better and it
shows that you really put in the effort.</p>

<p>The Go test suite also allows you to incorporate example functions which serve
as documentation <em>and</em> as tests. These functions need to start with <code>Example</code>.</p>

<pre><code class="language-go">func ExampleEven() {
    if Even(2) {
        fmt.Printf(&quot;Is even\n&quot;)
    }
    // Output: <span class="callout">1</span>
    // Is even
}
</code></pre>

<p>Those last two comments lines <span class="callout">1</span> are part of the example, <code>go test</code> uses those
to check the <em>generated</em> output with the text in the comments. If there is
a mismatch the test fails.</p>

<h2 id="useful-packages">Useful packages</h2>

<p>The standard libary of Go includes a huge number of packages. It is very
enlightening to browse the <code>$GOROOT/src</code> directory and look at the
packages. We cannot comment on each package, but the following are worth
a mention: <sup class="footnote-ref" id="fnref:The-descriptions"><a href="#fn:The-descriptions">12</a></sup></p>

<dl>
<dt><code>fmt</code></dt>
<dd><p><span class="index" id="idxref:83"></span>
Package <code>fmt</code> implements formatted I/O with functions analogous
to C&rsquo;s <code>printf</code> and <code>scanf</code>. The format verbs are derived
from C&rsquo;s but are simpler. Some verbs (%-sequences) that can be used:</p>

<ul>
<li><em>%v</em>, the value in a default format. when printing structs, the plus flag (%+v) adds field names.</li>
<li><em>%#v</em>, a Go-syntax representation of the value.</li>
<li><em>%T</em>, a Go-syntax representation of the type of the value.</li>
</ul></dd>
<dt><code>io</code></dt>
<dd><p><span class="index" id="idxref:84"></span>
This package provides basic interfaces to I/O primitives.
Its primary job is to wrap existing implementations of such primitives,
such as those in package os, into shared public interfaces that
abstract the functionality, plus some other related primitives.</p></dd>
<dt><code>bufio</code></dt>
<dd><p><span class="index" id="idxref:85"></span>
This package implements buffered I/O.  It wraps an
<code>io.Reader</code>
or
<code>io.Writer</code>
object, creating another object (Reader or Writer) that also implements
the interface but provides buffering and some help for textual I/O.</p></dd>
<dt><code>sort</code></dt>
<dd><p><span class="index" id="idxref:86"></span>
The <code>sort</code> package provides primitives for sorting arrays
and user-defined collections.</p></dd>
<dt><code>strconv</code></dt>
<dd><p><span class="index" id="idxref:87"></span>
The <code>strconv</code> package implements conversions to and from
string representations of basic data types.</p></dd>
<dt><code>os</code></dt>
<dd><p><span class="index" id="idxref:88"></span>
The <code>os</code> package provides a platform-independent interface to operating
system functionality.  The design is Unix-like.</p></dd>
<dt><code>sync</code></dt>
<dd><p><span class="index" id="idxref:89"></span>
The package <code>sync</code> provides basic synchronization primitives such as mutual
exclusion locks.</p></dd>
<dt><code>flag</code></dt>
<dd><p><span class="index" id="idxref:90"></span>
The <code>flag</code> package implements command-line flag parsing.</p></dd>
<dt><code>encoding/json</code></dt>
<dd><p><span class="index" id="idxref:91"></span>
The <code>encoding/json</code> package implements encoding and decoding of JSON objects as
defined in RFC 4627 <cite class="informative"><a href="#RFC4627"><sup>[RFC4627]</sup></a></cite>.</p></dd>
<dt><code>html/template</code></dt>
<dd><p><span class="index" id="idxref:92"></span>
Data-driven templates for generating textual output such as HTML.</p>

<p>Templates are executed by applying them to a data structure.  Annotations in
the template refer to elements of the data structure (typically a field of
a struct or a key in a map) to control execution and derive values to be
displayed.  The template walks the structure as it executes and the &ldquo;cursor&rdquo;
@ represents the value at the current location in the structure.</p></dd>
<dt><code>net/http</code></dt>
<dd><p><span class="index" id="idxref:93"></span>
The <code>net/http</code> package implements parsing of HTTP requests, replies,
and URLs and provides an extensible HTTP server and a basic
HTTP client.</p></dd>
<dt><code>unsafe</code></dt>
<dd><p><span class="index" id="idxref:94"></span>
The <code>unsafe</code> package contains operations that step around the type safety of Go programs.
Normally you don&rsquo;t need this package, but it is worth mentioning that <em>unsafe</em> Go programs
are possible.</p></dd>
<dt><code>reflect</code></dt>
<dd><p><span class="index" id="idxref:95"></span>
The <code>reflect</code> package implements run-time reflection, allowing a program to
manipulate objects with arbitrary types.  The typical use is to take a
value with static type <code>interface{}</code> and extract its dynamic type
information by calling <code>TypeOf</code>, which returns an object with interface
type <code>Type</code>. See <a href="#interfaces"></a>, Section <a href="#introspection-and-reflection"></a>.</p></dd>
<dt><code>os/exec</code></dt>
<dd><p><span class="index" id="idxref:96"></span> The <code>os/exec</code> package runs external commands.</p></dd>
</dl>

<h2 id="exercises-2">Exercises</h2>

<h3 id="stack-as-package" class="exercise" data-difficulty="0">Stack as package</h3>

<ol>
<li><p>See the Stack exercise. In this exercise we want to create a separate package
for that code. Create a proper package for your stack implementation, <code>Push</code>,
<code>Pop</code> and the <code>Stack</code> type need to be exported.</p></li>

<li><p>Write a simple unit test for this package.
You should at least test that a <code>Pop</code> works after a <code>Push</code>.</p></li>
</ol>

<h3 id="answer-12" class="answer">Answer</h3>

<ol>
<li><p>There are a few details that should be changed to make a proper package
for our stack. First, the exported functions should begin with a capital
letter and so should <code>Stack</code>. The package file is named <code>stack-as-package.go</code>
and contains:</p>

<pre><code class="language-go">package stack

// Stack holds the items.
type Stack struct {
	i    int
	data [10]int
}

// Push pushes an item on the stack.
func (s *Stack) Push(k int) {
	s.data[s.i] = k
	s.i++
}

// Pop pops an item from the stack.
func (s *Stack) Pop() (ret int) {
	s.i--
	ret = s.data[s.i]
	return
}
</code></pre></li>

<li><p>To make the unit testing work properly you need to do some
preparations. We&rsquo;ll come to those in a minute. First the actual unit test.
Create a file with the name <code>pushpop_test.go</code>, with the following contents:</p></li>
</ol>

<pre><code class="language-go">package stack

import &quot;testing&quot;

func TestPushPop(t *testing.T) {
	c := new(Stack)
	c.Push(5)
	if c.Pop() != 5 {
		t.Log(&quot;Pop doesn't give 5&quot;)
		t.Fail()
	}
}
</code></pre>

<p>For <code>go test</code> to work we need to put our package files in a directory
under <code>$GOPATH/src</code>:</p>

<pre><code>% mkdir $GOPATH/src/stack
% cp pushpop_test.go $GOPATH/src/stack
% cp stack-as-package.go $GOPATH/src/stack
</code></pre>

<p>Yields:</p>

<pre><code>% go test stack
ok stack 0.001s
</code></pre>

<h3 id="calculator" class="exercise" data-difficulty="2">Calculator</h3>

<ol>
<li>Create a reverse polish calculator. Use your stack package.</li>
</ol>

<h3 id="answer-13" class="answer">Answer</h3>

<ol>
<li>This is one answer:</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strconv&quot;
)

var reader *bufio.Reader = bufio.NewReader(os.Stdin)
var st = new(Stack)

type Stack struct {
	i    int
	data [10]int
}

func (s *Stack) push(k int) {
	if s.i+1 &gt; 9 {
		return
	}
	s.data[s.i] = k
	s.i++
}

func (s *Stack) pop() (ret int) {
	s.i--
	if s.i &lt; 0 {
		s.i = 0
		return
	}
	ret = s.data[s.i]
	return
}

func main() {
	for {
		s, err := reader.ReadString('\n')
		var token string
		if err != nil {
			return
		}
		for _, c := range s {
			switch {
			case c &gt;= '0' &amp;&amp; c &lt;= '9':
				token = token + string(c)
			case c == ' ':
				r, _ := strconv.Atoi(token)
				st.push(r)
				token = &quot;&quot;
			case c == '+':
				fmt.Printf(&quot;%d\n&quot;, st.pop()+st.pop())
			case c == '*':
				fmt.Printf(&quot;%d\n&quot;, st.pop()*st.pop())
			case c == '-':
				p := st.pop()
				q := st.pop()
				fmt.Printf(&quot;%d\n&quot;, q-p)
			case c == 'q':
				return
			default:
				//error
			}
		}
	}
}
</code></pre>

<h1 id="beyond-the-basics">Beyond the basics</h1>
<figure>
<blockquote class="epigraph">
<p>Go has pointers but not pointer arithmetic. You cannot use a pointer
variable to walk through the bytes of a string.</p>

<hr>
</blockquote>
<figcaption>Go For C++ Programmers &ndash; Go Authors
</figcaption>
</figure>

<p>In this chapter we delve deeper into the language.</p>

<p>Go has pointers. There is however no pointer arithmetic, so they act more like
references than pointers that you may know from C. Pointers are useful. Remember
that when you call a function in Go, the variables are
<em>pass-by-value</em>. So, for efficiency and the possibility to modify a passed value
 <em>in</em> functions we have pointers.</p>

<p>You declare a pointer by prefixing the type with an &lsquo;<code>*</code>&rsquo;: <code>var p *int</code>. Now <code>p</code>
is a pointer to an integer value. All newly declared variables are assigned
their zero value and pointers are no different. A newly declared pointer, or
just a pointer that points to nothing, has a nil-value <span class="index" id="idxref:97"></span>. In other
languages this is often called a NULL pointer in Go it is just <code>nil</code>. To make
a pointer point to something you can use the address-of operator
<span class="index" id="idxref:98"></span> (<code>&amp;</code>), which we demonstrate here:</p>

<pre><code class="language-go">var p *int
fmt.Printf(&quot;%v&quot;, p) <span class="callout">1</span>

var i int	    <span class="callout">2</span>
p = &amp;i		    <span class="callout">3</span>

fmt.Printf(&quot;%v&quot;, p) <span class="callout">4</span>
</code></pre>

<p>This <span class="callout">1</span> Prints <code>nil</code>. Declare <span class="callout">2</span> an integer variable <code>i</code>. Make <code>p</code> point <span class="callout">3</span>
to <code>i</code>, i.e. take the address of <code>i</code>. And this <span class="callout">4</span> will print something like
<code>0x7ff96b81c000a</code>. De-referencing a pointer is done by prefixing the pointer
variable with <code>*</code>.</p>

<p>As said, there is no pointer arithmetic, so if you write: <code>*p++</code>, it is
interpreted as <code>(*p)++</code>: first reference and then increment the
value.<span class="index" id="idxref:99"></span></p>

<h2 id="allocation">Allocation</h2>

<p>Go also has garbage collection, meaning that you don&rsquo;t have to worry about
memory deallocation.<sup class="footnote-ref" id="fnref:The-downside-is"><a href="#fn:The-downside-is">13</a></sup></p>

<p>To allocate memory Go has two primitives, <code>new</code> and <code>make</code>. They do different
things and apply to different types, which can be confusing, but the rules are
simple. The following sections show how to handle allocation in Go and hopefully
clarifies the somewhat artificial distinction between <code>new</code> <span class="index" id="idxref:100"></span>
and <code>make</code> <span class="index" id="idxref:101"></span>.</p>

<h3 id="allocation-with-new">Allocation with new</h3>

<p>The built-in function <code>new</code> is essentially the same as its namesakes in other
languages: <code>new(T)</code> allocates zeroed storage for a new item of type <code>T</code> and
returns its address, a value of type <code>*T</code>. Or in other words, it returns
a pointer to a newly allocated zero value of type <code>T</code>. This is important to
remember.</p>

<p>The documentation for <code>bytes.Buffer</code> states that &ldquo;the zero value for Buffer is
an empty buffer ready to use.&rdquo;. Similarly, <code>sync.Mutex</code> does not have an
explicit constructor or Init method. Instead, the zero value for a <code>sync.Mutex</code>
is defined to be an unlocked mutex.</p>

<h3 id="allocation-with-make">Allocation with make</h3>

<p>The built-in function <code>make(T, args)</code> serves a purpose different from <code>new(T)</code>.
It creates slices, maps, and channels <em>only</em>, and it returns an initialized (not
zero!) value of type <code>T</code>, and not a pointer: <code>*T</code>. The reason for the
distinction is that these three types are, under the covers, references to data
structures that must be initialized before use. A slice, for example, is
a three-item descriptor containing a pointer to the data (inside an array), the
length, and the capacity; until those items are initialized, the slice is <code>nil</code>.
For slices, maps, and channels, <code>make</code> initializes the internal data structure
and prepares the value for use.</p>

<p>For instance, <code>make([]int, 10, 100)</code> allocates an array of 100 ints and then
creates a slice structure with length 10 and a capacity of 100 pointing at the
first 10 elements of the array. In contrast, <code>new([]int)</code> returns a pointer to
a newly allocated, zeroed slice structure, that is, a pointer to a <code>nil</code> slice
value. These examples illustrate the difference between <code>new</code> and <code>make</code>.</p>

<pre><code class="language-go">var p *[]int = new([]int)       <span class="callout">1</span>
var v  []int = make([]int, 100) <span class="callout">2</span>

var p *[]int = new([]int)       <span class="callout">3</span>
*p = make([]int, 100, 100)

v := make([]int, 100)           <span class="callout">4</span>
</code></pre>

<p>Allocates <span class="callout">1</span> slice structure; rarely useful. <code>v</code> <span class="callout">2</span> refers to a new array of
100 ints. At <span class="callout">3</span> we make it unnecessarily complex, <span class="callout">4</span> is more idiomatic.</p>

<p>Remember that <code>make</code> applies only to maps, slices and channels and does not
return a pointer. To obtain an explicit pointer allocate with <code>new</code>.</p>

<aside>
<p><strong>new</strong> allocates; <strong>make</strong> initializes.</p>

<p>The above two paragraphs can be summarized as:</p>

<ul>
<li><code>new(T)</code> returns <code>*T</code> pointing to a zeroed <code>T</code></li>
<li><code>make(T)</code> returns an initialized <code>T</code></li>
</ul>

<p>And of course <code>make</code> is only used for slices, maps and channels.</p>
</aside>

<h3 id="constructors-and-composite-literals">Constructors and composite literals</h3>

<p>Sometimes the zero value isn&rsquo;t good enough and an initializing constructor is
necessary, as in this example taken from the package <code>os</code>.</p>

<pre><code class="language-go">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
</code></pre>

<p>There&rsquo;s a lot of boiler plate in there. We can simplify it using a
<em>composite literal</em> <span class="index" id="idxref:102"></span>, which is an expression that
 creates a new instance each time it is evaluated.</p>

<pre><code class="language-go">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &amp;f	<span class="callout">1</span>
}
</code></pre>

<p>It is OK to return the address of a local variable <span class="callout">1</span> the storage associated
with the variable survives after the function returns.</p>

<p>In fact, taking the address of a composite literal allocates a fresh instance
each time it is evaluated, so we can combine these last two lines.<sup class="footnote-ref" id="fnref:Taking-the-addre"><a href="#fn:Taking-the-addre">14</a></sup></p>

<pre><code class="language-go">return &amp;File{fd, name, nil, 0}
</code></pre>

<p>The items (called fields) of a composite literal are laid out in order and must
all be present. However, by labeling the elements explicitly as field:value
pairs, the initializers can appear in any order, with the missing ones left as
their respective zero values. Thus we could say</p>

<pre><code class="language-go">return &amp;File{fd: fd, name: name}
</code></pre>

<p>As a limiting case, if a composite literal contains no fields at all, it creates
a zero value for the type. The expressions <code>new(File)</code> and <code>&amp;File{}</code> are
equivalent. In fact the use of <code>new</code> is discouraged.</p>

<p>Composite literals can also be created for arrays, slices, and maps, with the
field labels being indices or map keys as appropriate. In these examples, the
initializations work regardless of the values of <code>Enone</code>, and <code>Einval</code>, as long
as they are distinct:</p>

<pre><code class="language-go">ar := [...]string{Enone: &quot;no error&quot;, Einval: &quot;invalid argument&quot;}
sl := []string{Enone: &quot;no error&quot;, Einval: &quot;invalid argument&quot;}
ma := map[int]string {Enone: &quot;no error&quot;, Einval: &quot;invalid argument&quot;}
</code></pre>

<h2 id="defining-your-own-types">Defining your own types</h2>

<p>Of course Go allows you to define new types, it does this with the
<code>type</code><span class="index" id="idxref:103"></span> keyword: <code>type foo int</code></p>

<p>This creates a new type <code>foo</code> which acts like an <code>int</code>. Creating more sophisticated
types is done with the <code>struct</code> <span class="index" id="idxref:104"></span> keyword. An example would
be when we want record somebody&rsquo;s name (<code>string</code>) and age (<code>int</code>) in a single
structure and make it a new type:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type NameAge struct {
	name string // Both non exported fields.
	age  int
}

func main() {
	a := new(NameAge)
	a.name = &quot;Pete&quot;
	a.age = 42
	fmt.Printf(&quot;%v\n&quot;, a)
}
</code></pre>

<p>Apropos, the output of <code>fmt.Printf(&quot;%v\n&quot;, a)</code> is <code>&amp;{Pete 42}</code></p>

<p>That is nice! Go knows how to print your structure. If you only want to print
one, or a few, fields of the structure you&rsquo;ll need to use <code>.&lt;field name&gt;</code>. For
example to only print the name:</p>

<pre><code class="language-go">fmt.Printf(&quot;%s&quot;, a.name)
</code></pre>

<h3 id="more-on-structure-fields">More on structure fields</h3>

<p>As said each item in a structure is called a field<span class="index" id="idxref:105"></span>. A struct with no
fields: <code>struct {}</code>. Or one with four fields:</p>

<pre><code class="language-go">struct {
    x, y int
    A *[]int
    F func()
}
</code></pre>

<p>If you omit the name for a field, you create an anonymous field (((field,
anonymous))), for instance:</p>

<pre><code class="language-go">struct {
    T1        // Field name is T1.
    *T2       // Field name is T2.
    P.T3      // Field name is T3.
    x, y int  // Field names are x and y.
}
</code></pre>

<p>Note that field names that start with a capital letter are exported, i.e. can be
set or read from other packages. Field names that start with a lowercase are
private to the current package. The same goes for functions defined in packages,
see <a href="#packages"></a> for the details.</p>

<h3 id="methods">Methods</h3>

<p>If you create functions that work on your newly defined type, you can take two
routes:</p>

<ol>
<li>Create a function that takes the type as an argument.</li>
</ol>

<pre><code class="language-go">func doSomething(n1 *NameAge, n2 int) { /* */ }
</code></pre>

<ol start="2">
<li>Create a function that works on the type (see <em>receiver</em> in <a href="#functions"></a>):</li>
</ol>

<pre><code class="language-go">func (n1 *NameAge) doSomething(n2 int) { /* */ }
</code></pre>

<p>This is a method call, which can be used as:</p>

<pre><code class="language-go">var n *NameAge
n.doSomething(2)
</code></pre>

<p>Whether to use a function or method is entirely up to the programmer, but if you
want to satisfy an interface (see the next chapter) you must use methods. If no
such requirement exists it is a matter of taste whether to use functions or
methods.</p>

<p>But keep the following in mind, this is quoted from <cite class="informative"><a href="#go_spec"><sup>[go_spec]</sup></a></cite>:</p>

<blockquote>
<p>If <code>x</code> is
addressable and <code>&amp;x</code>&rsquo;s method set contains <code>m</code>,
<code>x.m()</code> is shorthand for <code>(&amp;x).m()</code>.</p>
</blockquote>

<p>In the above case this means that the following is <em>not</em> an error:</p>

<pre><code class="language-go">var n NameAge	    // Not a pointer
n.doSomething(2)
</code></pre>

<p>Here Go will search the method list for <code>n</code> of type <code>NameAge</code>, come up empty and
will then <em>also</em> search the method list for the type <code>*NameAge</code> and will
translate this call to <code>(&amp;n).doSomething(2)</code>.</p>

<p>There is a subtle but major difference between the following type declarations.
Also see the Section &ldquo;Type Declarations&rdquo; <cite class="informative"><a href="#go_spec"><sup>[go_spec]</sup></a></cite>. Suppose we have:</p>

<pre><code class="language-go">// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock impl. */ }
func (m *Mutex) Unlock()  { /* Unlock impl. */ }
</code></pre>

<p>We now create two types in two different manners:</p>

<ul>
<li><code>type NewMutex Mutex</code>.</li>
<li><code>type PrintableMutex struct{Mutex}</code>.</li>
</ul>

<p><code>NewMutex</code> is equal to <code>Mutex</code>, but it <em>does not</em> have <em>any</em> of the methods of
<code>Mutex</code>. In other words its method set is empty. But <code>PrintableMutex</code> <em>has</em>
<em>inherited</em> <span class="index" id="idxref:106"></span> the method set from <code>Mutex</code>. The Go term
 for this is <em>embedding</em> <span class="index" id="idxref:107"></span>. In the words of <cite class="informative"><a href="#go_spec"><sup>[go_spec]</sup></a></cite>:</p>

<blockquote>
<p>The method set of <code>*PrintableMutex</code> contains the methods
<code>Lock</code> and <code>Unlock</code> bound to its anonymous field <code>Mutex</code>.</p>
</blockquote>

<h2 id="conversions">Conversions</h2>

<p>Sometimes you want to convert a type to another type. This is possible in Go,
but there are some rules. For starters, converting from one value to another is
done by operators (that look like functions: <code>byte()</code>) and not all conversions
are allowed.</p>
<figure>
<table id="tab-conversion">
<thead>
<tr>
<th>From</th>
<th><code>b []byte</code></th>
<th><code>i []int</code></th>
<th><code>r []rune</code></th>
<th><code>s string</code></th>
<th><code>f float32</code></th>
<th><code>i int</code></th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>To</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td><code>[]byte</code></td>
<td>·</td>
<td></td>
<td></td>
<td><code>[]byte(s)</code></td>
<td></td>
<td></td>
</tr>

<tr>
<td><code>[]int</code></td>
<td></td>
<td>·</td>
<td></td>
<td><code>[]int(s)</code></td>
<td></td>
<td></td>
</tr>

<tr>
<td><code>[]rune</code></td>
<td></td>
<td></td>
<td></td>
<td><code>[]rune(s)</code></td>
<td></td>
<td></td>
</tr>

<tr>
<td><code>string</code></td>
<td><code>string(b)</code></td>
<td><code>string(i)</code></td>
<td><code>string(r)</code></td>
<td>·</td>
<td></td>
<td></td>
</tr>

<tr>
<td><code>float32</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>·</td>
<td><code>float32(i)</code></td>
</tr>

<tr>
<td><code>int</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><code>int(f)</code></td>
<td>·</td>
</tr>
</tbody>
</table>
<figcaption>Valid conversions, <code>float64</code> works the same as <code>float32</code>.</figcaption>
</figure>

<ul>
<li><p>From a <code>string</code> to a slice of bytes or runes.</p>

<pre><code class="language-go">mystring := &quot;hello this is string&quot;
byteslice := []byte(mystring)
</code></pre>
<p>Converts to a <code>byte</code> slice, each <code>byte</code> contains the integer value of the
corresponding byte in the string. Note that as strings in Go are encoded in
UTF-8 some characters in the string may end up in 1, 2, 3 or 4 bytes.</p>

<pre><code class="language-go">runeslice  := []rune(mystring)
</code></pre>
<p>Converts to an <code>rune</code> slice, each <code>rune</code> contains a Unicode code point.
Every character from the string corresponds to one rune.</p></li>

<li><p>From a slice of bytes or runes to a <code>string</code>.</p>

<pre><code class="language-go">b := []byte{'h','e','l','l','o'} // Composite literal.
s := string(b)
i := []rune{257,1024,65}
r := string(i)
</code></pre></li>
</ul>

<p>For numeric values the following conversions are defined:</p>

<ul>
<li>Convert to an integer with a specific (bit) length: <code>uint8(int)</code></li>
<li>From floating point to an integer value: <code>int(float32)</code>. This discards the
fraction part from the floating point value.</li>
<li>And the other way around: <code>float32(int)</code>.</li>
</ul>

<h3 id="user-defined-types-and-conversions">User defined types and conversions</h3>

<p>How can you convert between the types you have defined yourself? We create two
types here <code>Foo</code> and <code>Bar</code>, where <code>Bar</code> is an alias for <code>Foo</code>:</p>

<pre><code class="language-go">type foo struct { int }  // Anonymous struct field.
type bar foo             // bar is an alias for foo.
</code></pre>

<p>Then we:</p>

<pre><code class="language-go">var b bar = bar{1} // Declare `b` to be a `bar`.
var f foo = b	   // Assign `b` to `f`.
</code></pre>

<p>Which fails on the last line with:
<code>cannot use b (type bar) as type foo in assignment</code></p>

<p>This can be fixed with a conversion: <code>var f foo = foo(b)</code></p>

<p>Note that converting structures that are not identical in their fields is more
difficult. Also note that converting <code>b</code> to a plain <code>int</code> also fails; an integer
is not the same as a structure containing an integer.</p>

<h2 id="exercises-3">Exercises</h2>

<h3 id="map-function-with-interfaces" class="exercise" data-difficulty="2">Map function with interfaces</h3>

<ol>
<li>Use the answer from the earlier map exercise but now
make it generic using interfaces. Make it at least work for
ints and strings.</li>
</ol>

<h3 id="answer-14" class="answer">Answer</h3>

<ol>
<li></li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

// Define the empty interface as a type.
type e interface{}

func mult2(f e) e {
	switch f.(type) {
	case int:
		return f.(int) * 2
	case string:
		return f.(string) + f.(string) + f.(string) + f.(string)
	}
	return f
}

func Map(n []e, f func(e) e) []e {
	m := make([]e, len(n))
	for k, v := range n {
		m[k] = f(v)
	}
	return m
}

func main() {
	m := []e{1, 2, 3, 4}
	s := []e{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}
	mf := Map(m, mult2)
	sf := Map(s, mult2)
	fmt.Printf(&quot;%v\n&quot;, mf)
	fmt.Printf(&quot;%v\n&quot;, sf)
}
</code></pre>

<h3 id="pointers" class="exercise" data-difficulty="1">Pointers</h3>

<ol>
<li><p>Suppose we have defined the following structure:</p>

<pre><code class="language-go">type Person struct {
    name string
    age	 int
}
</code></pre>
<p>What is the difference between the following two lines?</p>

<pre><code class="language-go">var p1 Person
p2 := new(Person)
</code></pre></li>

<li><p>What is the difference between the following two allocations?</p>

<pre><code class="language-go">func Set(t *T) {
    x = t
}
</code></pre>
<p>and</p>

<pre><code class="language-go">func Set(t T) {
    x= &amp;t
}
</code></pre></li>
</ol>

<h3 id="answer-15" class="answer">Answer</h3>

<ol>
<li><p>The expression, <code>var p1 Person</code> allocates a <code>Person</code>-<em>value</em> to <code>p1</code>. The type of <code>p1</code> is <code>Person</code>.
The second line: <code>p2 := new(Person)</code> allocates memory and assigns a <em>pointer</em> to <code>p2</code>. The type of <code>p2</code> is
<code>*Person</code>.</p></li>

<li><p>In the first function, <code>x</code> points to the same thing that <code>t</code> does, which is the same thing that the
actual argument points to. So in the second function, we have an &ldquo;extra&rdquo; variable containing a copy of the
interesting value. In the second function, <code>x</code> points to a new (heap-allocated) variable <code>t</code> which contains
a copy of whatever the actual argument value is.</p></li>
</ol>

<h3 id="linked-list" class="exercise" data-difficulty="1">Linked List</h3>

<ol>
<li><p>Make use of the package <code>container/list</code> to create
a (doubly) linked list. Push the values 1, 2 and 4 to the list and then
print it.</p></li>

<li><p>Create your own linked list implementation. And perform the same actions
as above.</p></li>
</ol>

<h3 id="answer-16" class="answer">Answer</h3>

<ol>
<li>The following is the implementation of a program using doubly
linked lists from <code>container/list</code>.</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;container/list&quot;
	&quot;fmt&quot;
)

func main() {
	l := list.New()
	l.PushBack(1)
	l.PushBack(2)
	l.PushBack(4)

	for e := l.Front(); e != nil; e = e.Next() {
		fmt.Printf(&quot;%v\n&quot;, e.Value)
	}
}
</code></pre>

<ol start="2">
<li>The following is a program implementing a simple doubly
linked list supporting <code>int</code> values.</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;errors&quot; <span class="callout">1</span>
	&quot;fmt&quot;
)

type Value int <span class="callout">2</span>

type Node struct { <span class="callout">3</span>
	Value
	prev, next *Node
}

type List struct {
	head, tail *Node
}

func (l *List) Front() *Node { <span class="callout">4</span>
	return l.head
}

func (n *Node) Next() *Node {
	return n.next
}

func (l *List) Push(v Value) *List {
	n := &amp;Node{Value: v} <span class="callout">5</span>

	if l.head == nil { <span class="callout">6</span>
		l.head = n
	} else {
		l.tail.next = n <span class="callout">7</span>
		n.prev = l.tail <span class="callout">8</span>
	}
	l.tail = n <span class="callout">9</span>

	return l
}

var errEmpty = errors.New(&quot;List is empty&quot;)

func (l *List) Pop() (v Value, err error) {
	if l.tail == nil { <span class="callout">10</span>
		err = errEmpty
	} else {
		v = l.tail.Value     <span class="callout">11</span>
		l.tail = l.tail.prev <span class="callout">12</span>
		if l.tail == nil {
			l.head = nil <span class="callout">13</span>
		}
	}

	return v, err
}

func main() {
	l := new(List)

	l.Push(1)
	l.Push(2)
	l.Push(4)

	for n := l.Front(); n != nil; n = n.Next() {
		fmt.Printf(&quot;%v\n&quot;, n.Value)
	}

	fmt.Println()

	for v, err := l.Pop(); err == nil; v, err = l.Pop() {
		fmt.Printf(&quot;%v\n&quot;, v)
	}
}
</code></pre>

<p>Import &lt;<span class="callout">1</span>&gt; the packages we will need. At &lt;<span class="callout">2</span>&gt; we declare a type for the value our list will contain,
this is not strictly neccesary. And at &lt;<span class="callout">3</span>&gt; we declare a type for the each node in our list.
At &lt;<span class="callout">4</span>&gt; we define the <code>Front</code> method for our list.
When pushing, create a new Node &lt;<span class="callout">5</span>&gt; with the provided value. If the list is empty &lt;<span class="callout">6</span>&gt;,
put the new node at the head. Otherwise &lt;<span class="callout">7</span>&gt; put it at the tail and make sure &lt;<span class="callout">8</span>&gt;
the new node points back to the previously existing one. At &lt;<span class="callout">9</span>&gt; we re-adjust tail
to the newly inserted node.</p>

<p>In the Pop <span class="callout">10</span> method, we return an error if the list is empty. If it is not empty <span class="callout">11</span>
we save the last value. And then <span class="callout">12</span> discard the last node from the list. Finally at <span class="callout">13</span>
we make sure the list is consistent if it becomes empty.</p>

<h3 id="cat" class="exercise" data-difficulty="1">Cat</h3>

<ol>
<li><p>Write a program which mimics the Unix program <code>cat</code>.</p></li>

<li><p>Make it support the <code>-n</code> flag, where each line is numbered.</p></li>

<li><p>The solution to the above question given in contains a bug. Can you spot and fix it?</p></li>
</ol>

<h3 id="answer-17" class="answer">Answer</h3>

<ol>
<li>The following is implemention of <code>cat</code> which also supports a -n flag to number each line.</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io&quot; <span class="callout">1</span>
	&quot;os&quot;
)

var numberFlag = flag.Bool(&quot;n&quot;, false, &quot;number each line&quot;) // &lt;&lt;2&gt;&gt;

func cat(r *bufio.Reader) { <span class="callout">3</span>
	i := 1
	for {
		buf, e := r.ReadBytes('\n') <span class="callout">4</span>
		if e == io.EOF {            <span class="callout">5</span>
			break
		}
		if *numberFlag { <span class="callout">6</span>
			fmt.Fprintf(os.Stdout, &quot;%5d  %s&quot;, i, buf)
			i++
		} else { <span class="callout">7</span>
			fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)
		}
	}
	return
}

func main() {
	flag.Parse()
	if flag.NArg() == 0 {
		cat(bufio.NewReader(os.Stdin))
	}
	for i := 0; i &lt; flag.NArg(); i++ {
		f, e := os.Open(flag.Arg(i))
		if e != nil {
			fmt.Fprintf(os.Stderr, &quot;%s: error reading from %s: %s\n&quot;,
				os.Args[0], flag.Arg(i), e.Error())
			continue
		}
		cat(bufio.NewReader(f))
	}
}
</code></pre>

<p>At <span class="callout">1</span> we include all the packages we need.
 Here <span class="callout">2</span> we define a new flag &ldquo;n&rdquo;, which defaults to off. Note that we get the help (-h) for free.
 Start the function <span class="callout">3</span> that actually reads the file&rsquo;s contents and displays it;
 Read one line at the time at <span class="callout">4</span>. And stop <span class="callout">5</span> if we hit the end.
 If we should number each line, print the line number and then the line itself <span class="callout">6</span>.
 Otherwise <span class="callout">7</span> we could just print the line.</p>

<ol start="2">
<li>The bug show itself when the last line of the input does not
contain a newline. Or worse, when the input contains one line without a
closing newline nothing is shown at all. A better solution is the following
program.</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

var numberFlag = flag.Bool(&quot;n&quot;, false, &quot;number each line&quot;)

func cat(r *bufio.Reader) {
	i := 1
	for {
		buf, e := r.ReadBytes('\n')
		if e == io.EOF &amp;&amp; string(buf) == &quot;&quot; {
			break
		}
		if *numberFlag {
			fmt.Fprintf(os.Stdout, &quot;%5d  %s&quot;, i, buf)
			i++
		} else {
			fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)
		}
	}
	return
}

func main() {
	flag.Parse()
	if flag.NArg() == 0 {
		cat(bufio.NewReader(os.Stdin))
	}
	for i := 0; i &lt; flag.NArg(); i++ {
		f, e := os.Open(flag.Arg(i))
		if e != nil {
			fmt.Fprintf(os.Stderr, &quot;%s: error reading from %s: %s\n&quot;,
				os.Args[0], flag.Arg(i), e.Error())
			continue
		}
		cat(bufio.NewReader(f))
	}
}
</code></pre>

<h3 id="method-calls" class="exercise" data-difficulty="2">Method calls</h3>

<ol>
<li><p>Suppose we have the following
program. Note the package <code>container/vector</code> was once part
of Go, but was removed when the <code>append</code> built-in was introduced.
However, for this question this isn&rsquo;t important. The package implemented
a stack-like structure, with push and pop methods.</p>

<pre><code class="language-go">package main


import &quot;container/vector&quot;


func main() {
    k1 := vector.IntVector{}
    k2 := &amp;vector.IntVector{}
    k3 := new(vector.IntVector)
    k1.Push(2)
    k2.Push(3)
    k3.Push(4)
}
</code></pre>
<p>What are the types of <code>k1</code>, <code>k2</code> and <code>k3</code>?</p></li>

<li><p>Now, this program compiles and runs OK. All the <code>Push</code>
operations work even though the variables are of a different type. The
documentation for <code>Push</code> says:</p>

<blockquote>
<p><code>func (p *IntVector) Push(x int)</code>
Push appends x to the end of the vector.</p>
</blockquote>

<p>So the receiver has to be of type <code>*IntVector</code>, why does the code
above (the Push statements) work correctly then?</p></li>
</ol>

<h3 id="answer-18" class="answer">Answer</h3>

<ol>
<li><p>The type of <code>k1</code> is <code>vector.IntVector</code>. Why? We use
a composite literal (the <code>{}</code>), so we get a value of that type
back. The variable <code>k2</code> is of <code>*vector.IntVector</code>, because we
take the address (<code>&amp;</code>) of the composite literal. And finally
<code>k3</code> has also the type <code>*vector.IntVector</code>, because <code>new</code>
returns a pointer to the type.</p></li>

<li><p>The answer is given in <cite class="informative"><a href="#go_spec"><sup>[go_spec]</sup></a></cite> in the section &ldquo;Calls&rdquo;,
where among other things it says:</p></li>
</ol>

<blockquote>
<p>A method call <code>x.m()</code> is valid if the method set of (the type of)
<code>x</code>
contains <code>m</code> and the argument list can be assigned to the parameter list
of <code>m</code>. If <code>x</code> is addressable and <code>&amp;x</code>&rsquo;s method set
contains <code>m</code>, <code>x.m()</code> is shorthand for <code>(&amp;x).m()</code>.</p>
</blockquote>

<p>In other words because <code>k1</code> is addressable and
<code>*vector.IntVector</code> <em>does</em> have the <code>Push</code> method, the
call <code>k1.Push(2)</code> is translated by Go into
<code>(&amp;k1).Push(2)</code> which makes the type system happy again (and
you too &ndash; now you know this).<sup class="footnote-ref" id="fnref:Also-see-methods"><a href="#fn:Also-see-methods">15</a></sup></p>

<h1 id="interfaces">Interfaces</h1>
<figure>
<blockquote class="epigraph">
<p>I have this phobia about having my body penetrated surgically. You know what
I mean?</p>

<hr>
</blockquote>
<figcaption>eXistenZ &ndash; Ted Pikul
</figcaption>
</figure>

<p>In Go, the word <em>interface</em><span class="index" id="idxref:108"></span> is overloaded to mean several
different things. Every type has an interface, which is the <em>set of methods
defined</em> for <span class="index" id="idxref:109"></span> that type. This bit of code defines
a struct type <code>S</code> with one field, and defines two methods for <code>S</code>. <sup class="footnote-ref" id="fnref:The-following-te"><a href="#fn:The-following-te">16</a></sup></p>
<figure>
<pre><code class="language-go">type S struct { i int }
func (p *S) Get() int  { return p.i }
func (p *S) Put(v int) { p.i = v }
</code></pre>
<figcaption>Defining a struct and methods on it.
</figcaption>
</figure>

<p>You can also define an <span class="index" id="idxref:110"></span>interface type, which is simply
a set of methods. This defines an interface <code>I</code> with two methods:</p>

<pre><code class="language-go">type I interface {
    Get() int
    Put(int)
}
</code></pre>

<p><code>S</code> is a valid <em>implementation</em> for interface <code>I</code>, because it defines the two
methods which <code>I</code> requires. Note that this is true even though there is no
explicit declaration that <code>S</code> implements <code>I</code>.</p>

<p>A Go program can use this fact via yet another meaning of interface, which is an
interface value: <span class="index" id="idxref:111"></span></p>

<pre><code class="language-go">func f(p I) { <span class="callout">1</span>
    fmt.Println(p.Get()) <span class="callout">2</span>
    p.Put(1) <span class="callout">3</span>
}
</code></pre>

<p>At <span class="callout">1</span> we declare a function that takes an interface type as the argument.
Because <code>p</code> implements <code>I</code>, it <em>must</em> have the <code>Get()</code> method, which we call at
<span class="callout">2</span>. And the same holds true for the <code>Put()</code> method at <span class="callout">3</span>. Because <code>S</code>
implements <code>I</code>, we can call the function <code>f</code> passing in a pointer to a value of
type <code>S</code>: <code>var s S; f(&amp;s)</code></p>

<p>The reason we need to take the address of <code>s</code>, rather than a value of type <code>S</code>,
is because we defined the methods on <code>s</code> to operate on pointers, see the
definition in the code above. This is not a requirement &ndash; we could have defined
the methods to take values &ndash; but then the <code>Put</code> method would not work as
expected.</p>

<p>The fact that you do not need to declare whether or not a type implements an
interface means that Go implements a form of duck typing <span class="index" id="idxref:112"></span>
<cite class="informative"><a href="#duck_typing"><sup>[duck_typing]</sup></a></cite>. This is not pure duck typing, because when possible the
Go compiler will statically check whether the type implements the interface.
However, Go does have a purely dynamic aspect, in that you can convert from one
interface type to another. In the general case, that conversion is checked at
run time. If the conversion is invalid &ndash; if the type of the value stored in
the existing interface value does not satisfy the interface to which it is being
converted &ndash; the program will fail with a run time error.</p>

<p>Interfaces in Go are similar to ideas in several other programming languages:
pure abstract virtual base classes in C++, typeclasses in Haskell or duck typing
in Python. However there is no other language which combines interface values,
static type checking, dynamic run time conversion, and no requirement for
explicitly declaring that a type satisfies an interface. The result in Go is
powerful, flexible, efficient, and easy to write.</p>

<h2 id="which-is-what">Which is what?</h2>

<p>Let&rsquo;s define another type <code>R</code> that also implements the interface <code>I</code>:</p>

<pre><code class="language-go">type R struct { i int }
func (p *R) Get() int  { return p.i }
func (p *R) Put(v int) { p.i = v }
</code></pre>

<p>The function <code>f</code> can now accept variables of type <code>R</code> and <code>S</code>.</p>

<p>Suppose you need to know the actual type in the function <code>f</code>. In Go you can
figure that out by using a type switch<span class="index" id="idxref:113"></span>.</p>

<pre><code class="language-go">func f(p I) {
    switch t := p.(type) { <span class="callout">1</span>
        case *S: <span class="callout">2</span>
        case *R: <span class="callout">2</span>
        default: <span class="callout">3</span>
    }
}
</code></pre>

<p>At <span class="callout">1</span> we use the type switch, note that the <code>.(type)</code> syntax is <em>only</em> valid
within a <code>switch</code> statement. We store the value in the variable <code>t</code>. The
subsequent cases <span class="callout">2</span> each check for a different <em>actual</em> type. And we can even
have a <code>default</code> <span class="callout">3</span> clause. It is worth pointing out that both <code>case R</code> and
<code>case s</code> aren&rsquo;t possible, because <code>p</code> needs to be a pointer in order to satisfy
<code>i</code>.</p>

<p>A type switch isn&rsquo;t the only way to discover the type at <em>run-time</em>.</p>

<pre><code class="language-go">if t, ok := something.(I); ok { <span class="callout">1</span>
    // ...
}
</code></pre>

<p>You can also use a &ldquo;comma, ok&rdquo; form <span class="callout">1</span> to see if an interface type implements
a specific interface. If <code>ok</code> is true, <code>t</code> will hold the type of <code>something</code>.
When you are sure a variable implements an interface you can use: <code>t := something.(I)</code> .</p>

<h2 id="empty-interface">Empty interface</h2>

<p>Since every type satisfies the empty interface: <code>interface{}</code> we can create
a generic function which has an empty interface as its argument:</p>

<pre><code class="language-go">func g(something interface{}) int {
    return something.(I).Get()
}
</code></pre>

<p>The <code>return something.(I).Get()</code> is the tricky bit in this function. The value
<code>something</code> has type <code>interface{}</code>, meaning no guarantee of any methods at all:
it could contain any type. The <code>.(I)</code> is a type assertion <span class="index" id="idxref:114"></span>
which converts <code>something</code> to an interface of type <code>I</code>. If we have that type we
can invoke the <code>Get()</code> function. So if we create a new variable of the type
<code>*S</code>, we can just call <code>g()</code>, because <code>*S</code> also implements the empty interface.</p>

<pre><code class="language-go">s = new(S)
fmt.Println(g(s));
</code></pre>

<p>The call to <code>g</code> will work fine and will print 0. If we however invoke <code>g()</code> with
a value that does not implement <code>I</code> we have a problem:</p>

<pre><code class="language-go">var i int
fmt.Println(g(i))
</code></pre>

<p>This compiles, but when we run this we get slammed with: &ldquo;panic: interface
conversion: int is not main.I: missing method Get&rdquo;.</p>

<p>Which is completely true, the built-in type <code>int</code> does not have a <code>Get()</code>
method.</p>

<h2 id="methods-1">Methods</h2>

<p>Methods are functions that have a receiver (see <a href="#functions"></a>).
You can define methods on any type (except on non-local types, this includes
built-in types: the type <code>int</code> can not have methods).
You can however make a new integer type with its own methods. For example:</p>

<pre><code class="language-go">type Foo int

func (self Foo) Emit() {
    fmt.Printf(&quot;%v&quot;, self)
}

type Emitter interface {
    Emit()
}
</code></pre>

<p>Doing this on non-local (types defined in other packages) types yields an error
&ldquo;cannot define new methods on non-local type int&rdquo;.</p>

<h2 id="methods-on-interface-types">Methods on interface types</h2>

<p>An interface defines a set of methods. A method contains the actual code. In
other words, an interface is the definition and the methods are the
implementation. So a receiver can not be an interface type, doing so results in
a &ldquo;invalid receiver type &hellip;&rdquo; compiler error. The authoritative word from the
language spec <cite class="informative"><a href="#go_spec"><sup>[go_spec]</sup></a></cite>:</p>

<blockquote>
<p>The receiver type must be of the form <code>T</code> or <code>*T</code> where <code>T</code> is a type name. <code>T</code>
is called the receiver base type or just base type. The base type must not be
a pointer or interface type and must be declared in the same package as the
method.</p>
</blockquote>

<aside>
<p>Creating a pointer to an interface value is a useless action in Go. It is in
fact illegal to create a pointer to an interface value. The release notes for an
earlier Go release that made them illegal leave no room for doubt:</p>

<blockquote>
<p>The language change is that uses of pointers to interface values no longer
automatically de-reference the pointer.  A pointer to an interface value is
more often a beginner&rsquo;s bug than correct code.</p>
</blockquote>
</aside>

<h2 id="interface-names">Interface names</h2>

<p>By convention, one-method interfaces are named by the method name plus the <em>-er</em>
suffix: Read<em>er</em>, Writ<em>er</em>, Formatt<em>er</em> etc.</p>

<p>There are a number of such names and it&rsquo;s productive to honor them and the
function names they capture. <code>Read</code>, <code>Write</code>, <code>Close</code>, <code>Flush</code>, <code>String</code> and so
on have canonical signatures and meanings. To avoid confusion, don&rsquo;t give your
method one of those names unless it has the same signature and meaning.
Conversely, if your type implements a method with the same meaning as a method
on a well-known type, give it the same name and signature; call your
string-converter method <code>String</code> not <code>ToString</code>. <sup class="footnote-ref" id="fnref:Text-copied-from"><a href="#fn:Text-copied-from">17</a></sup></p>

<h2 id="a-sorting-example">A sorting example</h2>

<p>Recall the Bubblesort exercise, where we sorted an array of integers:</p>

<pre><code class="language-go">func bubblesort(n []int) {
    for i := 0; i &lt; len(n)-1; i++ {
        for j := i + 1; j &lt; len(n); j++ {
            if n[j] &lt; n[i] {
                n[i], n[j] = n[j], n[i]
            }
        }
    }
}
</code></pre>

<p>A version that sorts strings is identical except for the signature of the
function: <code>func bubblesortString(n []string) { /* ... */ }</code> . Using this
approach would lead to two functions, one for each type. By using interfaces we
can make this more <span class="index" id="idxref:115"></span> generic. Let&rsquo;s create a new function that will
sort both strings and integers, something along the lines of this non-working
example:</p>

<pre><code class="language-go">func sort(i []interface{}) {  <span class="callout">1</span>
    switch i.(type) {         <span class="callout">2</span>
    case string:              <span class="callout">3</span>
        // ...
    case int:
        // ...
    }
    return /* ... */          <span class="callout">4</span>
}
</code></pre>

<p>Our function will receive a slice of empty interfaces at <span class="callout">1</span>. We then <span class="callout">2</span> use a
type switch to find out what the actual type of the input is. And then <span class="callout">3</span>
then sort accordingly. And, when done, return <span class="callout">4</span> the sorted slice.</p>

<p>But when we call this function with <code>sort([]int{1, 4, 5})</code>, it fails with:
&ldquo;cannot use i (type []int) as type []interface { } in function argument&rdquo;</p>

<p>This is because Go can not easily convert to a <em>slice</em> of interfaces.
Just converting to an interface is easy, but to a slice is much more costly.
The full mailing list discussion on this subject can be found at
<cite class="informative"><a href="#go_nuts_interfaces"><sup>[go_nuts_interfaces]</sup></a></cite>. To keep a long story short: Go does not (implicitly) convert slices for you.</p>

<p>So what is the Go way of creating such a &ldquo;generic&rdquo; function?
Instead of doing the type inference ourselves with a type switch, we let
Go do it implicitly:
The following steps are required:</p>

<ul>
<li><p>Define an interface type (called <code>Sorter</code> here) with a number of methods
needed for sorting. We will at least need a function to get the length of the
slice, a function to compare two values and a swap function.</p>

<pre><code class="language-go">type Sorter interface {
    Len() int           // len() as a method.
    Less(i, j int) bool // p[j] &lt; p[i] as a method.
    Swap(i, j int)      // p[i], p[j] = p[j], p[i] as a method.
}
</code></pre></li>

<li><p>Define new types for the slices we want to sort. Note that we declare slice types:</p>

<pre><code class="language-go">type Xi []int
type Xs []string
</code></pre></li>

<li><p>Implementation of the methods of the <code>Sorter</code> interface.
For integers:</p>

<pre><code class="language-go">func (p Xi) Len() int               {return len(p)}
func (p Xi) Less(i int, j int) bool {return p[j] &lt; p[i]}
func (p Xi) Swap(i int, j int)      {p[i], p[j] = p[j], p[i]}
</code></pre>
<p>And for strings:</p>

<pre><code class="language-go">func (p Xs) Len() int               {return len(p)}
func (p Xs) Less(i int, j int) bool {return p[j] &lt; p[i]}
func (p Xs) Swap(i int, j int)      {p[i], p[j] = p[j], p[i]}
</code></pre></li>

<li><p>Write a <em>generic</em> Sort function that works on the <code>Sorter</code> interface.</p>

<pre><code class="language-go">func Sort(x Sorter) { <span class="callout">1</span>
    for i := 0; i &lt; x.Len() - 1; i++ { <span class="callout">2</span>
        for j := i + 1; j &lt; x.Len(); j++ {
            if x.Less(i, j) {
                x.Swap(i, j)
            }
        }
    }
}
</code></pre>
<p>At <span class="callout">1</span> <code>x</code> is now of the <code>Sorter</code> type and using the defined methods for this interface we implement
Bubblesort at <span class="callout">2</span>.</p>

<p>Now we can use our <em>generic</em> <code>Sort</code> function as follows:</p>

<pre><code class="language-go">ints := Xi{44, 67, 3, 17, 89, 10, 73, 9, 14, 8}
strings := Xs{&quot;nut&quot;, &quot;ape&quot;, &quot;elephant&quot;, &quot;zoo&quot;, &quot;go&quot;}


Sort(ints)
fmt.Printf(&quot;%v\n&quot;, ints)
Sort(strings)
fmt.Printf(&quot;%v\n&quot;, strings)
</code></pre></li>
</ul>

<h2 id="listing-interfaces-in-interfaces">Listing interfaces in interfaces</h2>

<p>Take a look at the following example of an interface definition, this one is
from the package <code>container/heap</code>:</p>

<pre><code class="language-go">type Interface interface {
    sort.Interface
    Push(x interface{})
    Pop() interface{}
}
</code></pre>

<p>Here another interface is listed inside the definition of <code>heap.Interface</code>, this
may look odd, but is perfectly valid, remember that on the surface an interface is nothing
more than a listing of methods. <code>sort.Interface</code> is also such a listing, so it is
perfectly legal to include it in the interface.</p>

<h2 id="introspection-and-reflection">Introspection and reflection</h2>

<p>In the following example we want to look at the &ldquo;tag&rdquo; (here named &ldquo;namestr&rdquo;)
defined in the type definition of <code>Person</code>. To do this we need the
<code>reflect</code><span class="index" id="idxref:116"></span> package (there is no other way in Go). Keep in
mind that looking at a tag means going back to the <em>type</em> definition. So we use
the <code>reflect</code> package to figure out the type of the variable and <em>then</em> access
the tag.</p>
<figure>
<pre><code class="language-go">type Person struct {
    name string &quot;namestr&quot;
    age  int
}

func ShowTag(i interface{}) { <span class="callout">1</span>
    switch t := reflect.TypeOf(i); t.Kind() {
    case reflect.Ptr: <span class="callout">2</span>
        tag := t.Elem().Field(0).Tag
    //             &lt;&lt;3&gt;&gt;     &lt;&lt;4&gt;&gt;       &lt;&lt;5&gt;&gt;
</code></pre>
<figcaption>Introspection using reflection.
</figcaption>
</figure>

<p>We are calling <code>ShowTag</code> at <span class="callout">1</span> with a <code>*Person</code>, so at <span class="callout">2</span> we&rsquo;re expecting
a <code>reflect.Ptr</code>. We are dealing with a <code>Type</code> <span class="callout">3</span> and according to the
documentation <sup class="footnote-ref" id="fnref:go-doc-reflect"><a href="#fn:go-doc-reflect">18</a></sup>:</p>

<blockquote>
<p>Elem returns a type&rsquo;s element type.
It panics if the type&rsquo;s Kind is not Array, Chan, Map, Ptr, or Slice.</p>
</blockquote>

<p>So on <code>t</code> we use <code>Elem()</code> to get the value the pointer points to. We have now
dereferenced the pointer and are &ldquo;inside&rdquo; our structure. We then <span class="callout">4</span> use
<code>Field(0)</code> to access the zeroth field.</p>

<p>The struct <code>StructField</code> has a <code>Tag</code> member which returns the tag-name as
a string. So on the <span class="math inline">\(0^{th}\)</span> field we can unleash <code>.Tag</code> <span class="callout">5</span> to access this
name: <code>Field(0).Tag</code>. This gives us <code>namestr</code>.</p>

<p>To make the difference between types and values more clear, take a look at the
following code:</p>
<figure>
<pre><code class="language-go">func show(i interface{}) {
    switch t := i.(type) {
    case *Person:
        t := reflect.TypeOf(i)  <span class="callout">1</span>
        v := reflect.ValueOf(i) <span class="callout">2</span>
        tag := t.Elem().Field(0).Tag <span class="callout">3</span>
        name := v.Elem().Field(0).String() <span class="callout">4</span>
    }
}
</code></pre>
<figcaption>Reflection and the type and value.
</figcaption>
</figure>

<p>At <span class="callout">1</span> we create <code>t</code> the type data of <code>i</code>, and <code>v</code> gets the actual values at
<span class="callout">2</span>. Here at <span class="callout">3</span> we want to get to the &ldquo;tag&rdquo;. So we need <code>Elem()</code> to redirect
the pointer, access the first field and get the tag. Note that we operate on <code>t</code>
a <code>reflect.Type</code>. Now <span class="callout">4</span> we want to get access to the <em>value</em> of one of the
members and we employ <code>Elem()</code> on <code>v</code> to do the redirection. we have &ldquo;arrived&rdquo;
at the structure. Then we go to the first field <code>Field(0)</code> and invoke the
<code>String()</code> method on it.</p>
<figure><p><img src="fig/reflection.png" alt="Peeling away the layers using reflection." /></p>
<figcaption>Peeling away the layers using reflection. Going from a <code>*Person</code> via <code>Elem</code> using the
methods described in <code>go doc reflect</code> to get the actual <code>string</code> contained within.&ldquo;)
</figcaption>
</figure>

<p>Setting a value works similarly as getting a value, but only works on
<em>exported</em> members. Again some code:</p>
<figure>
<pre><code class="language-go">type Person struct {
    name string
    age  int
}

func Set(i interface{}) {
    switch i.(type) {
    case *Person:
        r := reflect.ValueOf(i)
        r.Elem(0).Field(0).SetString(&quot;Albert Einstein&quot;)
    }
}
</code></pre>
<figcaption>Reflect with <em>private</em> member.
</figcaption>
</figure>
<figure>
<pre><code class="language-go">type Person struct {
    Name string
    age  int
}

func Set(i interface{}) {
    switch i.(type) {
    case *Person:
        r := reflect.ValueOf(i)
        r.Elem().Field(0).SetString(&quot;Albert Einstein&quot;)
    }
}
</code></pre>
<figcaption>Reflect with <em>public</em> member.
</figcaption>
</figure>

<p>The first program compiles and runs, but when you run it, you are greeted with a
stack trace and a <em>run time</em> error:
&ldquo;panic: reflect.Value.SetString using value obtained using unexported field&rdquo;.</p>

<p>The second program works OK and sets the member <code>Name</code> to &ldquo;Albert Einstein&rdquo;.
Of course this only works when you call <code>Set()</code> with a pointer argument.</p>

<h2 id="exercises-4">Exercises</h2>

<p class="exercise" data-dificulty="2">### Interfaces and max()</p>

<p>In the maximum exercise we created a max function that works on a slice of
integers.  The question now is to create a program that shows the maximum number
and that works for both integers and floats.  Try to make your program as
generic as possible, although that is quite difficult in this case.</p>

<h3 id="answer-19">Answer</h3>

<p>The following program calculates a maximum. It is as generic as you can get with
Go.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func Less(l, r interface{}) bool { <span class="callout">1</span>
    switch l.(type) {
    case int:
        if _, ok := r.(int); ok {
            return l.(int) &lt; r.(int) <span class="callout">2</span>
        }
    case float32:
        if _, ok := r.(float32); ok {
            return l.(float32) &lt; r.(float32) <span class="callout">3</span>
        }
    }
    return false
}

func main() {
    var a, b, c int = 5, 15, 0
    var x, y, z float32 = 5.4, 29.3, 0.0

    if c = a; Less(a, b) { <span class="callout">4</span>
        c = b
    }
    if z = x; Less(x, y) { <span class="callout">4</span>
        z = y
    }
    fmt.Println(c, z)
}
</code></pre>

<p>We could have chosen to make the return type of this <span class="callout">1</span> function an
<code>interface{}</code>, but that would mean that a caller would always have to do a type
assertion to extract the actual type from the interface. At <span class="callout">2</span> we compare the
parameters. All parameters are confirmed to be integers, so this is legit. And
at <span class="callout">3</span> we do the some for floats. At <span class="callout">4</span> we get the maximum value for <code>a</code>, <code>b</code>
and <code>x</code> and <code>y</code>.</p>

<h3 id="pointers-and-reflection" class="exercise" data-difficulty="1">Pointers and reflection</h3>

<p>One of the last paragraphs in section <a href="#introspection-and-reflection"></a>
has the following words:</p>

<blockquote>
<p>The code on the right works OK and sets the member <code>Name</code>
to &ldquo;Albert Einstein&rdquo;. Of course this only works when you call <code>Set()</code>
with a pointer argument.</p>
</blockquote>

<p>Why is this the case?</p>

<h3 id="answer-20">Answer</h3>

<p>When called with a non-pointer argument the variable is a copy (call-by-value).
So you are doing the reflection voodoo on a copy. And thus you are <em>not</em>
changing the original value, but only this copy.</p>

<h1 id="concurrency">Concurrency</h1>
<figure>
<blockquote class="epigraph">
<ul>
<li>Parallelism is about performance.</li>
<li>Concurrency is about program design.</li>
</ul>

<hr>
</blockquote>
<figcaption>Google I/O 2010 &ndash; Rob Pike
</figcaption>
</figure>

<p>In this chapter we will show off Go&rsquo;s ability for concurrent programming using
channels and goroutines. Goroutines are the central entity in Go&rsquo;s ability for
concurrency.</p>

<p>But what <em>is</em> a goroutine, from <cite class="informative"><a href="#effective_go"><sup>[effective_go]</sup></a></cite>:</p>

<blockquote>
<p>They&rsquo;re called goroutines because the existing terms &ndash; threads, coroutines,
processes, and so on &ndash; convey inaccurate connotations. A goroutine has a simple
model: <em>it is a function executing in parallel with other goroutines in the same
address space</em>. It is lightweight, costing little more than the allocation of
stack space. And the stacks start small, so they are cheap, and grow by
allocating (and freeing) heap storage as required.</p>
</blockquote>

<p>A goroutine <span class="index" id="idxref:117"></span> is a normal function, except that you start
it with the keyword <code>go</code>. <span class="index" id="idxref:118"></span></p>

<pre><code class="language-go">ready(&quot;Tea&quot;, 2)	    // Normal function call.
go ready(&quot;Tea&quot;, 2)  // ... as goroutine.
</code></pre>
<figure>
<pre><code class="language-go">func ready(w string, sec int) {
	time.Sleep(time.Duration(sec) * time.Second)
	fmt.Println(w, &quot;is ready!&quot;)
}

func main() {
	go ready(&quot;Tea&quot;, 2)    //&lt;1&gt;
	go ready(&quot;Coffee&quot;, 1) //&lt;1&gt;
	fmt.Println(&quot;I'm waiting&quot;)
	time.Sleep(5 * time.Second) //&lt;2&gt;
</code></pre>
<figcaption>Go routines in action.
</figcaption>
</figure>

<p>The following idea for a program was taken from <cite class="informative"><a href="#go_course_day3"><sup>[go_course_day3]</sup></a></cite>. We run
a function as two goroutines, the goroutines wait for an amount of time and then
print something to the screen. At <span class="callout">1</span> we start the goroutines. The <code>main</code>
function waits long enough at <span class="callout">2</span>, so that both goroutines will have printed
their text. Right now we wait for 5 seconds, but in fact we have no idea how
long we should wait until all goroutines have exited. This outputs:</p>

<pre><code class="language-go">I'm waiting         // Right away
Coffee is ready!    // After 1 second
Tea is ready!       // After 2 seconds
</code></pre>

<p>If we did not wait for the goroutines (i.e. remove the last line at <span class="callout">2</span>) the
program would be terminated immediately and any running goroutines would
<em>die with it</em>.</p>

<p>To fix this we need some kind of mechanism which allows us to
communicate with the goroutines. This mechanism is available to us in the form
of channels <span class="index" id="idxref:119"></span>. A channel can be compared to a two-way pipe in Unix
shells: you can send to and receive values from it. Those values can only be of
a specific type: the type of the channel. If we define a channel, we must also
define the type of the values we can send on the channel. Note that we must use
<code>make</code> to create a channel:</p>

<pre><code class="language-go">ci := make(chan int)
cs := make(chan string)
cf := make(chan interface{})
</code></pre>

<p>Makes <code>ci</code> a channel on which we can send and receive integers,
makes <code>cs</code> a channel for strings and <code>cf</code> a channel for types
that satisfy the empty interface.
Sending on a channel and receiving from it, is done with the same operator:
<code>&lt;-</code>. <span class="index" id="idxref:120"></span></p>

<p>Depending on the operands it figures out what to do:</p>

<pre><code class="language-go">ci &lt;- 1   // *Send* the integer 1 to the channel ci.
&lt;-ci      // *Receive* an integer from the channel ci.
i := &lt;-ci // *Receive* from the channel ci and store it in i.
</code></pre>

<p>Let&rsquo;s put this to use.</p>

<pre><code class="language-go">var c chan int <span class="callout">1</span>

func ready(w string, sec int) {
    time.Sleep(time.Duration(sec) * time.Second)
    fmt.Println(w, &quot;is ready!&quot;)
    c &lt;- 1	<span class="callout">2</span>
}

func main() {
    c = make(chan int) <span class="callout">3</span>
    go ready(&quot;Tea&quot;, 2) <span class="callout">4</span>
    go ready(&quot;Coffee&quot;, 1) <span class="callout">4</span>
    fmt.Println(&quot;I'm waiting, but not too long&quot;)
    &lt;-c <span class="callout">5</span>
    &lt;-c <span class="callout">5</span>
}
</code></pre>

<p>At <span class="callout">1</span> we declare <code>c</code> to be a variable that is a channel of ints. That is: this
channel can move integers. Note that this variable is global so that the
goroutines have access to it. At <span class="callout">2</span> in the <code>ready</code> function we send the integer
1 on the channel. In our <code>main</code> function we initialize <code>c</code> at <span class="callout">3</span> and start our
goroutines <span class="callout">4</span>. At <span class="callout">5</span> we Wait until we receive a value from the channel, the
value we receive is discarded. We have started two goroutines, so we expect two
values to receive.</p>

<p>There is still some remaining ugliness; we have to read twice from the channel
<span class="callout">5</span>). This is OK in this case, but what if we don&rsquo;t know how many goroutines we
started? This is where another Go built-in comes in: <code>select</code> (((keywords,
select))). With <code>select</code> you can (among other things) listen for incoming data
on a channel.</p>

<p>Using <code>select</code> in our program does not really make it shorter, because we run
too few go-routines. We remove last lines and replace them with the following:</p>

<pre><code class="language-go">L: for {
    select {
    case &lt;-c:
        i++
        if i &gt; 1 {
            break L
        }
    }
}
</code></pre>

<p>We will now wait as long as it takes. Only when we have received more than one
reply on the channel <code>c</code> will we exit the loop <code>L</code>.</p>

<h2 id="make-it-run-in-parallel">Make it run in parallel</h2>

<p>While our goroutines were running concurrently, they were not running in
parallel. When you do not tell Go anything there can only be one goroutine
running at a time. With <code>runtime.GOMAXPROCS(n)</code> you can set the number of
goroutines that can run in parallel. From the documentation:</p>

<blockquote>
<p>GOMAXPROCS sets the maximum number of CPUs that can be executing
simultaneously and returns the previous setting. If n &lt; 1, it does not
change the current setting. <em>This call will go away when the scheduler
improves.</em></p>
</blockquote>

<p>If you do not want to change any source code you can also set an environment
variable <code>GOMAXPROCS</code> to the desired value.</p>

<p>Note that the above discussion relates to older versions of Go. From
version 1.5 and above, <code>GOMAXPROCS</code> defaults to the number of CPU
cores<cite class="informative"><a href="#go_1_5_release_notes"><sup>[go_1_5_release_notes]</sup></a></cite>.</p>

<h2 id="more-on-channels">More on channels</h2>

<p>When you create a channel in Go with <code>ch := make(chan bool)</code>, an unbuffered
channel <span class="index" id="idxref:121"></span> for bools is created. What does this mean for
your program? For one, if you read (<code>value := &lt;-ch</code>) it will block until there
is data to receive. Secondly anything sending (<code>ch &lt;- true</code>) will block until there
is somebody to read it. Unbuffered channels make a perfect tool for
synchronizing multiple goroutines. <span class="index" id="idxref:122"></span> <span class="index" id="idxref:123"></span></p>

<p>But Go allows you to specify the buffer size of a channel, which is quite simply
how many elements a channel can hold. <code>ch := make(chan bool, 4)</code>, creates
a buffered channel of bools that can hold 4 elements. The first 4 elements in
this channel are written without any blocking. When you write the 5<sup>th</sup> element,
your code <em>will</em> block, until another goroutine reads some elements from the
channel to make room. <span class="index" id="idxref:124"></span> <span class="index" id="idxref:125"></span></p>

<p>In conclusion, the following is true in Go:</p>
<p><span class="math display">\[
\textsf{ch := make(chan type, value)}
\left\{
\begin{array}{ll}
value == 0 &amp; \rightarrow \textsf{unbuffered} \\
value &gt;  0 &amp; \rightarrow \textsf{buffer }{} value{} \textsf{ elements}
\end{array}
\right.
\]</span></p><p>When a channel is closed the reading side needs to know this. The following code
will check if a channel is closed.</p>

<pre><code class="language-go">x, ok = &lt;-ch
</code></pre>

<p>Where <code>ok</code> is set to <code>true</code> the channel is not closed
<em>and</em> we&rsquo;ve read something. Otherwise <code>ok</code> is set to <code>false</code>. In that case the
channel was closed and the value received is a zero value of the
channel&rsquo;s type.</p>

<h2 id="exercises-5">Exercises</h2>

<h3 id="channels" class="exercise" data-difficulty="1">Channels</h3>

<ol>
<li><p>Modify the program you created in exercise <a href="#for-loop"></a> to use
channels, in other words, the function called in the body should now be
a goroutine and communication should happen via channels. You should not
worry yourself on how the goroutine terminates.</p></li>

<li><p>There are a few annoying issues left if you resolve question 1 above. One of
the problems is that the goroutine isn&rsquo;t neatly cleaned up when <code>main.main()</code>
exits. And worse, due to a race condition between the exit of <code>main.main()</code>
and <code>main.shower()</code> not all numbers are printed. It should print up until 9,
but sometimes it prints only to 8. Adding a second quit-channel you can
remedy both issues. Do this.</p></li>
</ol>

<h3 id="answer-21">Answer</h3>

<ol>
<li>A possible program is:</li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	ch := make(chan int)
	go shower(ch)
	for i := 0; i &lt; 10; i++ {
		ch &lt;- i
	}
}

func shower(c chan int) {
	for {
		j := &lt;-c
		fmt.Printf(&quot;%d\n&quot;, j)
	}
}
</code></pre>

<p>We start in the usual way, then at line 6 we create a new channel of
   ints. In the next line we fire off the function <code>shower</code> with
   the <code>ch</code> variable as it argument, so that we may communicate with
   it. Next we start our for-loop (lines 8-10) and in the loop
   we send (with <code>&lt;-</code>) our number to the function (now a goroutine) <code>shower</code>.</p>

<p>In the function <code>shower</code> we wait (as this blocks) until we receive a number
   (line 15). Any received number is printed (line 16) and then continue the
   endless loop started on line 14.</p>

<ol start="2">
<li>An answer is</li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	ch := make(chan int)
	quit := make(chan bool)
	go shower(ch, quit)
	for i := 0; i &lt; 10; i++ {
		ch &lt;- i
	}
	quit &lt;- false	// or true, does not matter
}

func shower(c chan int, quit chan bool) {
	for {
		select {
		case j := &lt;-c:
			fmt.Printf(&quot;%d\n&quot;, j)
		case &lt;-quit:
			break
		}
	}
}
</code></pre>

<p>On line 20 we read from the quit channel and we discard the value we read. We
   could have used <code>q := &lt;-quit</code>, but then we would have used the variable only
   once &mdash; which is illegal in Go. Another trick you might have pulled out of
   your hat may be: <code>_ = &lt;-quit</code>. This is valid in Go, but idomatic Go is the
   one given on line 20.</p>

<h3 id="fibonacci-ii" class="exercise" data-difficulty="2">Fibonacci II</h3>

<p>This is the same exercise as an earlier one <a href="#fibonacci"></a> in
exercise. For completeness the complete question:</p>

<blockquote>
<p>The Fibonacci sequence starts as follows: <span class="math inline">\(1, 1, 2, 3, 5, 8, 13, \ldots\)</span>
Or in mathematical terms:
<span class="math inline">\(x_1 = 1; x_2 = 1; x_n = x_{n-1} + &gt; x_{n-2}\quad\forall n &gt; 2\)</span>.</p>

<p>Write a function that takes an <code>int</code> value and gives
that many terms of the Fibonacci sequence.</p>
</blockquote>

<p><em>But</em> now the twist: You must use channels.</p>

<h3 id="answer-22">Answer</h3>

<p>The following program calculates the Fibonacci numbers using channels.</p>

<pre><code class="language-go">package main
import &quot;fmt&quot;

func dup3(in &lt;-chan int) (&lt;-chan int, &lt;-chan int, &lt;-chan int) {
	a, b, c := make(chan int, 2), make(chan int, 2), make(chan int, 2)
	go func() {
		for {
			x := &lt;-in
			a &lt;- x
			b &lt;- x
			c &lt;- x
		}
	}()
	return a, b, c
}

func fib() &lt;-chan int {
	x := make(chan int, 2)
	a, b, out := dup3(x)
	go func() {
		x &lt;- 0
		x &lt;- 1
		&lt;-a
		for {
			x &lt;- &lt;-a+&lt;-b
		}
	}()
	return out
}

func main() {
	x := fib()
	for i := 0; i &lt; 10; i++ {
		fmt.Println(&lt;-x)
	}
}

// See sdh33b.blogspot.com/2009/12/fibonacci-in-go.html
</code></pre>

<h1 id="communication">Communication</h1>
<figure>
<blockquote class="epigraph">
<p>Good communication is as stimulating as black coffee, and just as hard
to sleep after.</p>

<hr>
</blockquote>
<figcaption>&ndash; Anne Morrow Lindbergh
</figcaption>
</figure>

<p>In this chapter we are going to look at the building blocks in Go for
communicating with the outside world. We will look at files, directories,
networking and executing other programs. Central to Go&rsquo;s I/O are the interfaces
<code>io.Reader</code> and <code>io.Writer</code>. The <code>io.Reader</code> interface specifies one method
<code>Read(p []byte) (n int, err err)</code>.</p>

<p>Reading from (and writing to) files is easy in Go. This program
only uses the <code>os</code> package to read data from the file <code>/etc/passwd</code>.</p>

<pre><code class="language-go">package main

import (
	&quot;log&quot;
	&quot;os&quot;
)

func main() {
	buf := make([]byte, 1024)
	f, e := os.Open(&quot;/etc/passwd&quot;) <span class="callout">1</span>
	if e != nil {
		log.Fatalf(e)
	}
	defer f.Close() <span class="callout">2</span>
	for {
		n, e := f.Read(buf) <span class="callout">3</span>
		if e != nil {
			log.Fatalf(e) <span class="callout">4</span>
		}
		if n == 0 { <span class="callout">5</span>
			break
		}
		os.Stdout.Write(buf[:n]) <span class="callout">6</span>
	}
}
</code></pre>

<p>We open the file at <span class="callout">1</span> with <code>os.Open</code> that returns a <code>*os.File</code>
<code>*os.File</code> implements <code>io.Reader</code> and <code>io.Writer</code> interface.
After the <code>Open</code> we directly put the <code>f.Close()</code> which we defer until the function
return. At <span class="callout">3</span> we call <code>Read</code> on <code>f</code> and read up to 1024 bytes at the time. If anything
fails we bail out at <span class="callout">4</span>. If the number of bytes read is 0 we&rsquo;ve read the end of the
file <span class="callout">5</span>. And at <span class="callout">6</span> we output the buffer to standard output.</p>

<p>If you want to use buffered <span class="index" id="idxref:126"></span> I/O there is the
<code>bufio</code><span class="index" id="idxref:127"></span> package:</p>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;log&quot;
	&quot;os&quot;
)

func main() {
	buf := make([]byte, 1024)
	f, e := os.Open(&quot;/etc/passwd&quot;) <span class="callout">1</span>
	if e != nil {
		log.Fatalf(e)
	}
	defer f.Close()
	r := bufio.NewReader(f) <span class="callout">2</span>
	w := bufio.NewWriter(os.Stdout)
	defer w.Flush() <span class="callout">3</span>
	for {
		n, e := r.Read(buf) <span class="callout">4</span>
		if e != nil {
			log.Fatalf(e)
		}
		if n == 0 {
			break
		}
		w.Write(buf[0:n]) <span class="callout">5</span>
	}
}
</code></pre>

<p>Again, we open <span class="callout">1</span> the file. Then at <span class="callout">2</span> we
Turn <code>f</code> into a buffered <code>Reader</code>. <code>NewReader</code> expects an <code>io.Reader</code>, so you this will work.
Then at <span class="callout">4</span> we read and at <span class="callout">5</span> we write. We also call <code>Flush()</code> at <span class="callout">3</span> to flush all output.
This entire program could be optimized further by using <code>io.Copy</code>.</p>

<h2 id="io-reader">io.Reader</h2>

<p>As mentioned above the <code>io.Reader</code> <span class="index" id="idxref:128"></span> is an important interface in the language Go. A lot
(if not all) functions that need to read from something take an <code>io.Reader</code><span class="index" id="idxref:129"></span>
as input. To fulfill the interface a type needs to implement that one method.
The writing side <code>io.Writer</code>, has the <code>Write</code> method.</p>

<p>If you think of a new type in your program or package and you make it fulfill the <code>io.Reader</code>
or <code>io.Writer</code> interface, <em>the whole standard Go library can be used</em> on that type!</p>

<h2 id="some-examples">Some examples</h2>

<p>The previous program reads a file in its entirety, but a more common scenario is that
you want to read a file on a line-by-line basis. The following snippet shows a way
to do just that (we&rsquo;re discarding the error returned from <code>os.Open</code> here to keep
the examples smaller &ndash; don&rsquo;t ever do this in real life code).</p>

<pre><code class="language-go">f, _ := os.Open(&quot;/etc/passwd&quot;); defer f.Close()
r := bufio.NewReader(f) <span class="callout">1</span>
s, ok := r.ReadString('\n') <span class="callout">2</span>
</code></pre>

<p>At <span class="callout">1</span> make <code>f</code> a <code>bufio</code> to have access to the <code>ReadString</code> method. Then at <span class="callout">2</span> we read
a line from the input, <code>s</code>  now holds a string which we can manipulate with, for instance,
the <code>strings</code> package.</p>

<p>A more robust method (but slightly more complicated) is <code>ReadLine</code>, see the documentation
of the <code>bufio</code> package.</p>

<p>A common scenario in shell scripting is that you want to check if a directory
exists and if not, create one.</p>

<pre><code class="language-go">if [ ! -e name ]; then          if f, e := os.Stat(&quot;name&quot;); e != nil {
    mkdir name                      os.Mkdir(&quot;name&quot;, 0755)
else                            } else {
    # error                         // error
fi                              }
</code></pre>

<p>The similarity between these two examples (and with other scripting languages)
have prompted comments that Go has a &ldquo;script&rdquo;-like feel to it, i.e. programming
in Go can be compared to programming in an interpreted language (Python, Ruby,
Perl or PHP).</p>

<h2 id="command-line-arguments">Command line arguments</h2>

<p>Arguments from the command line are available inside your program via the string
slice <code>os.Args</code>, provided you have imported the package <code>os</code>. The <code>flag</code> package
<span class="index" id="idxref:130"></span>
has a more sophisticated interface, and also provides a way to parse flags. Take
this example from a DNS query tool:</p>

<pre><code class="language-go">dnssec := flag.Bool(&quot;dnssec&quot;, false, &quot;Request DNSSEC records&quot;) <span class="callout">1</span>
port := flag.String(&quot;port&quot;, &quot;53&quot;, &quot;Set the query port&quot;) <span class="callout">2</span>
flag.Usage = func() {   <span class="callout">3</span>
    fmt.Fprintf(os.Stderr, &quot;Usage: %s [OPTIONS] [name ...]\n&quot;, os.Args[0])
    flag.PrintDefaults() <span class="callout">4</span>
}
flag.Parse() <span class="callout">4</span>
</code></pre>

<p>At <span class="callout">1</span> we define a <code>bool</code> flag <code>-dnssec</code>. Note that this function returns
a <em>pointer</em> to the value, the <code>dnssec</code> is now a pointer to a <code>bool</code>. At <span class="callout">2</span> we
define an <code>strings</code> flag. Then at <span class="callout">3</span> we <em>redefine</em> the <code>Usage</code> variable of the
flag package so we can add some extra text. The <code>PrintDefaults</code> at <span class="callout">4</span> will
output the default help for the flags that are defined. Note even without
redefining a <code>flag.Usage</code> the flag <code>-h</code> is supported and will just output the help text
for each of the flags. Finally at <span class="callout">4</span> we call <code>Parse</code> that parses the command
line and fills the variables.</p>

<p>After the flags have been parsed you can used them: <code>if *dnssec { ... }</code></p>

<h2 id="executing-commands">Executing commands</h2>

<p>The <code>os/exec</code><span class="index" id="idxref:131"></span> package has functions to run external
commands, and is the premier way to execute commands from within a Go program.
It works by defining a <code>*exec.Cmd</code> structure for which it defines a number of
methods. Let&rsquo;s execute <code>ls -l</code>:</p>

<pre><code class="language-go">import &quot;os/exec&quot;

cmd := exec.Command(&quot;/bin/ls&quot;, &quot;-l&quot;)
err := cmd.Run()
</code></pre>

<p>The above example just runs &ldquo;ls -l&rdquo; without doing anything with the returned
data, capturing the standard output from a command is done as follows:</p>

<pre><code class="language-go">cmd := exec.Command(&quot;/bin/ls&quot;, &quot;-l&quot;)
buf, err := cmd.Output()
</code></pre>

<p>And <code>buf</code> is byte slice, that you can further use in your program.</p>

<h2 id="networking">Networking</h2>

<p>All network related types and functions can be found in the package <code>net</code>. One
of the most important functions in there is <code>Dial</code><span class="index" id="idxref:132"></span>. When
you <code>Dial</code> into a remote system the function returns a <code>Conn</code> interface type,
which can be used to send and receive information. The function <code>Dial</code> neatly
abstracts away the network family and transport. So IPv4 or IPv6, TCP or UDP can
all share a common interface.</p>

<p>Dialing a remote system (port 80) over TCP, then UDP and lastly TCP over IPv6
looks like this<sup class="footnote-ref" id="fnref:In-case-you-are"><a href="#fn:In-case-you-are">19</a></sup>:</p>

<pre><code class="language-go">conn, e := Dial(&quot;tcp&quot;, &quot;192.0.32.10:80&quot;)
conn, e := Dial(&quot;udp&quot;, &quot;192.0.32.10:80&quot;)
conn, e := Dial(&quot;tcp&quot;, &quot;[2620:0:2d0:200::10]:80&quot;)
</code></pre>

<p>If there were no errors (returned in <code>e</code>), you can use <code>conn</code> to read and write.
And <code>conn</code> implements the <code>io.Reader</code> and <code>io.Writer</code> interface. <sup class="footnote-ref" id="fnref:The-variable-con"><a href="#fn:The-variable-con">20</a></sup></p>

<p>But these are the low level nooks and crannies, you will almost always use
higher level packages, such as the <code>http</code> package. For instance a simple Get for
http:</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;http&quot;
    &quot;io/ioutil&quot;
)

func main() {
    r, err := http.Get(&quot;http://www.google.com/robots.txt&quot;)
    if err != nil {
        fmt.Printf(&quot;%s\n&quot;, err.String())
        return
    }
    b, err := ioutil.ReadAll(r.Body)
    r.Body.Close()
    if err == nil {
        fmt.Printf(&quot;%s&quot;, string(b))
    }
}
</code></pre>

<h2 id="exercises-6">Exercises</h2>

<h3 id="finger-daemon" class="exercise" data-difficulty="1">Finger daemon</h3>

<p>Write a finger daemon that works with the finger(1) command.</p>

<p>From the <a href="https://www.debian.org">Debian</a> package description:</p>

<blockquote>
<p>Fingerd is a simple daemon based on RFC 1196 <cite class="informative"><a href="#RFC1196"><sup>[RFC1196]</sup></a></cite> that provides an interface to the
&ldquo;finger&rdquo; program at most network sites.  The program is supposed to return a
friendly, human-oriented status report on either the system at the moment or a
particular person in depth.</p>
</blockquote>

<p>Stick to the basics and only support a username argument. If the user has a <code>.plan</code> file
show the contents of that file. So your program needs to be able to figure out:</p>

<ul>
<li>Does the user exist?</li>
<li>If the user exists, show the contents of the <code>.plan</code> file.</li>
</ul>

<h3 id="answer-23">Answer</h3>

<aside>
<p>This solution is from Fabian Becker.</p>
</aside>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;errors&quot;
	&quot;flag&quot;
	&quot;io/ioutil&quot;
	&quot;net&quot;
	&quot;os/user&quot;
)

func main() {
	flag.Parse()
	ln, err := net.Listen(&quot;tcp&quot;, &quot;:79&quot;)
	if err != nil {
		panic(err)
	}
	for {
		conn, err := ln.Accept()
		if err != nil {
			continue
		}
		go handleConnection(conn)
	}
}

func handleConnection(conn net.Conn) {
	defer conn.Close()
	reader := bufio.NewReader(conn)
	usr, _, _ := reader.ReadLine()

	if info, err := getUserInfo(string(usr)); err != nil {
		conn.Write([]byte(err.Error()))
	} else {
		conn.Write(info)
	}
}

func getUserInfo(usr string) ([]byte, error) {
	u, e := user.Lookup(usr)
	if e != nil {
		return nil, e
	}
	data, err := ioutil.ReadFile(u.HomeDir + &quot;.plan&quot;)
	if err != nil {
		return data, errors.New(&quot;User doesn't have a .plan file!\n&quot;)
	}
	return data, nil
}
</code></pre>

<h3 id="echo-server" class="exercise" data-difficulty="1">Echo server</h3>

<p>Write a simple echo server. Make it listen to TCP port number 8053 on localhost.
It should be able to read a line (up to the newline), echo back that line and
then close the connection.</p>

<p>Make the server concurrent so that every request is taken care of in a separate
goroutine.</p>

<h3 id="answer-24">Answer</h3>

<p>A simple echo server might be:</p>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;net&quot;
)

func main() {
	l, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8053&quot;)
	if err != nil {
		fmt.Printf(&quot;Failure to listen: %s\n&quot;, err.Error())
	}
	for {
		if c, err := l.Accept(); err == nil {
			Echo(c)
		}
	}
}

func Echo(c net.Conn) {
	defer c.Close()
	line, err := bufio.NewReader(c).ReadString('\n')
	if err != nil {
		fmt.Printf(&quot;Failure to read: %s\n&quot;, err.Error())
		return
	}
	_, err = c.Write([]byte(line))
	if err != nil {
		fmt.Printf(&quot;Failure to write: %s\n&quot;, err.Error())
		return
	}
}
</code></pre>

<p>When started you should see the following:</p>

<pre><code>% nc 127.0.0.1 8053
Go is *awesome*
Go is *awesome*
</code></pre>

<p>To make the connection handling concurrent we <em>only need to change one line</em> in our
echo server, the line:</p>

<pre><code class="language-go">if c, err := l.Accept(); err == nil { Echo(c) }
</code></pre>

<p>becomes:</p>

<pre><code class="language-go">if c, err := l.Accept(); err == nil { go Echo(c) }
</code></pre>

<h3 id="word-and-letter-count" class="exercise" data-difficulty="0">Word and Letter Count</h3>

<p>Write a small program that reads text from standard input and performs the
following actions:</p>

<ul>
<li>Count the number of characters (including spaces).</li>
<li>Count the number of words.</li>
<li>Count the numbers of lines</li>
</ul>

<p>In other words implement wc(1) (check you local manual page), however you only
have to read from standard input.</p>

<h3 id="answer-25">Answer</h3>

<p>The following program is an implementation of wc(1).</p>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func main() {
	var chars, words, lines int
	r := bufio.NewReader(os.Stdin) <span class="callout">1</span>
	for {
		switch s, ok := r.ReadString('\n'); true { <span class="callout">2</span>
		case ok != nil: <span class="callout">3</span>
			fmt.Printf(&quot;%d %d %d\n&quot;, chars, words, lines)
			return
		default: <span class="callout">4</span>
			chars += len(s)
			words += len(strings.Fields(s))
			lines++
		}
	}
}
</code></pre>

<p>At <span class="callout">1</span> we create a new reader that reads from standard input, we then read from
the input at <span class="callout">2</span>. And at <span class="callout">3</span> we check the value of <code>ok</code> and if we received an
error, we assume it was because of a EOF, So we print the current values;.
Otherwise <span class="callout">4</span> we count the charaters, words and increment the number lines.</p>

<h3 id="uniq" class="exercise" data-difficulty="0">Uniq</h3>

<p>Write a Go program that mimics the function of the Unix <code>uniq</code> command. This
program should work as follows, given a list with the following items:</p>

<pre><code>'a' 'b' 'a' 'a' 'a' 'c' 'd' 'e' 'f' 'g'
</code></pre>

<p>it should print only those items which don&rsquo;t have the same successor:</p>

<pre><code>'a' 'b' 'a' 'c' 'd' 'e' 'f' 'g'
</code></pre>

<p>The next listing is a Perl implementation of the algorithm.</p>

<pre><code class="language-pl">#!/usr/bin/perl
my @a = qw/a b a a a c d e f g/;
print my $first = shift @a;
foreach (@a) {
    if ($first ne $_) { print; $first = $_; }
}
</code></pre>

<h3 id="answer-26">Answer</h3>

<p>The following is a <code>uniq</code> implementation in Go.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	list := []string{&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}
	first := list[0]

	fmt.Printf(&quot;%s &quot;, first)
	for _, v := range list[1:] {
		if first != v {
			fmt.Printf(&quot;%s &quot;, v)
			first = v
		}
	}
}
</code></pre>

<h3 id="quine" class="exercise" data-difficulty="2">Quine</h3>

<p>A <em>Quine</em> is a program that prints itself. Write a Quine in Go.</p>

<h3 id="answer-27">Answer</h3>

<aside>
<p>This solution is from Russ Cox. It was posted to the Go Nuts mailing list.</p>
</aside>

<pre><code class="language-go">/* Go quine */
package main
import &quot;fmt&quot;
func main() {
 fmt.Printf(&quot;%s%c%s%c\n&quot;, q, 0x60, q, 0x60)
}
var q = `/* Go quine */
package main
import &quot;fmt&quot;
func main() {
 fmt.Printf(&quot;%s%c%s%c\n&quot;, q, 0x60, q, 0x60)
}
var q = `
</code></pre>

<h3 id="processes" class="exercise" data-difficulty="2">Processes</h3>

<p>Write a program that takes a list of all running processes and prints how many
child processes each parent has spawned. The output should look like:</p>

<pre><code>Pid 0 has 2 children: [1 2]
Pid 490 has 2 children: [1199 26524]
Pid 1824 has 1 child: [7293]
</code></pre>

<ul>
<li><p>For acquiring the process list, you&rsquo;ll need to capture the output of <code>ps -e
-opid,ppid,comm</code>. This output looks like:</p>

<pre><code>  PID  PPID COMMAND
 9024  9023 zsh
19560  9024 ps
</code></pre></li>

<li><p>If a parent has one child you must print <code>child</code>, if there is more than one
print <code>children</code>.</p></li>

<li><p>The process list must be numerically sorted, so you start with pid 0 and work
your way up.</p></li>
</ul>

<p>Here is a Perl version to help you on your way (or to create complete and utter confusion).</p>

<pre><code class="language-pl">#!/usr/bin/perl -l
my (%child, $pid, $parent);
my @ps=`ps -e -opid,ppid,comm`;	  # capture the output from `ps`
foreach (@ps[1..$#ps]) {	  # discard the header line
  ($pid, $parent, undef) = split; # split the line, discard 'comm'
  push @{$child{$parent}}, $pid;  # save the child PIDs on a list
}
# Walk through the sorted PPIDs
foreach (sort { $a &lt;=&gt; $b } keys %child) {
  print &quot;Pid &quot;, $_, &quot; has &quot;, @{$child{$_}}+0, &quot; child&quot;,
    @{$child{$_}} == 1 ? &quot;: &quot; : &quot;ren: &quot;, &quot;[@{$child{$_}}]&quot;;
}
</code></pre>

<h3 id="answer-28">Answer</h3>

<p>There is lots of stuff to do here. We can divide our program
up in the following sections:</p>

<ul>
<li>Starting <code>ps</code> and capturing the output.</li>
<li>Parsing the output and saving the child PIDs for each PPID.</li>
<li>Sorting the PPID list.</li>
<li>Printing the sorted list to the screen.</li>
</ul>

<p>In the solution presented below, we&rsquo;ve used a <code>map[int][]int</code>, i.e. a map
indexed with integers, pointing to a slice of ints &ndash; which holds the PIDs. The
builtin <code>append</code> is used to grow the integer slice.</p>

<p>A possible program is:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os/exec&quot;
	&quot;sort&quot;
	&quot;strconv&quot;
	&quot;strings&quot;
)

func main() {
	ps := exec.Command(&quot;ps&quot;, &quot;-e&quot;, &quot;-opid,ppid,comm&quot;)
	output, _ := ps.Output()
	child := make(map[int][]int)
	for i, s := range strings.Split(string(output), &quot;\n&quot;) {
		if i == 0 { // kill first line
			continue
		}
		if len(s) == 0 { // kill last line
			continue
		}
		f := strings.Fields(s)
		fpp, _ := strconv.Atoi(f[1]) // parent's pid
		fp, _ := strconv.Atoi(f[0])  // child's pid
		child[fpp] = append(child[fpp], fp)
	}
	schild := make([]int, len(child))
	i := 0
	for k, _ := range child {
		schild[i] = k
		i++
	}
	sort.Ints(schild)
	for _, ppid := range schild {
		fmt.Printf(&quot;Pid %d has %d child&quot;, ppid, len(child[ppid]))
		if len(child[ppid]) == 1 {
			fmt.Printf(&quot;: %v\n&quot;, child[ppid])
			continue
		}
		fmt.Printf(&quot;ren: %v\n&quot;, child[ppid])
	}
}
</code></pre>

<h3 id="number-cruncher" class="exercise" data-difficulty="2">Number cruncher</h3>

<ul>
<li>Pick six (6) random numbers from this list: <span class="math inline">\(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
25, 50, 75, 100\)</span> Numbers may be picked multiple times.</li>
<li>Pick one (1) random number (<span class="math inline">\(i\)</span>) in the range: <span class="math inline">\(1 \ldots 1000\)</span>.</li>
<li>Tell how, by combining the first 6 numbers (or a subset thereof)
with the operators <code>+,-,*</code> and <code>/</code>, you can make <span class="math inline">\(i\)</span>.</li>
</ul>

<p>An example. We have picked the numbers: 1, 6, 7, 8, 8 and 75. And <span class="math inline">\(i\)</span> is
977. This can be done in many different ways, one way is:
<span class="math inline">\( ((((1 * 6) * 8) + 75) * 8) - 7 = 977\)</span>
or
<span class="math inline">\( (8*(75+(8*6)))-(7/1) = 977\)</span></p>

<p>Implement a number cruncher that works like that. Make it print the solution in
a similar format (i.e. output should be infix with parenthesis) as used above.</p>

<p>Calculate <em>all</em> possible solutions and show them (or only show how many there
are). In the example above there are 544 ways to do it.</p>

<h3 id="answer-29">Answer</h3>

<p>The following is one possibility. It uses recursion and backtracking to get
an answer. When starting <code>permrec</code> we give 977 as the first argument:</p>

<pre><code>% ./permrec 977
1+(((6+7)*75)+(8/8)) = 977  #1
...                         ...
((75+(8*6))*8)-7 = 977      #542
(((75+(8*6))*8)-7)*1 = 977  #543
(((75+(8*6))*8)-7)/1 = 977  #544
</code></pre>

<pre><code class="language-go">package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;strconv&quot;
)

const (
	_ = 1000 * iota
	ADD
	SUB
	MUL
	DIV
	MAXPOS = 11
)

var mop = map[int]string{ADD: &quot;+&quot;, SUB: &quot;-&quot;, MUL: &quot;*&quot;, DIV: &quot;/&quot;}
var (
	ok    bool
	value int
)

type Stack struct {
	i    int
	data [MAXPOS]int
}

func (s *Stack) Reset()     { s.i = 0 }
func (s *Stack) Len() int   { return s.i }
func (s *Stack) Push(k int) { s.data[s.i] = k; s.i++ }
func (s *Stack) Pop() int   { s.i--; return s.data[s.i] }

var found int
var stack = new(Stack)

func main() {
	flag.Parse()
	list := []int{1, 6, 7, 8, 8, 75, ADD, SUB, MUL, DIV}
	magic, ok := strconv.Atoi(flag.Arg(0)) // Arg0 is i
	if ok != nil {
		return
	}
	f := make([]int, MAXPOS)
	solve(f, list, 0, magic)
}

func solve(form, numberop []int, index, magic int) {
	var tmp int
	for i, v := range numberop {
		if v == 0 {
			goto NEXT
		}
		if v &lt; ADD { // it's a number, save it
			tmp = numberop[i]
			numberop[i] = 0
		}
		form[index] = v
		value, ok = rpncalc(form[0 : index+1])

		if ok &amp;&amp; value == magic {
			if v &lt; ADD {
				numberop[i] = tmp // reset and go on
			}
			found++
			fmt.Printf(&quot;%s = %d  #%d\n&quot;, rpnstr(form[0:index+1]), value, found)
		}

		if index == MAXPOS-1 {
			if v &lt; ADD {
				numberop[i] = tmp // reset and go on
			}
			goto NEXT
		}
		solve(form, numberop, index+1, magic)
		if v &lt; ADD {
			numberop[i] = tmp // reset and go on
		}
	NEXT:
	}
}

func rpnstr(r []int) (ret string) { // Convert rpn to infix notation
	s := make([]string, 0) // Still memory intensive
	for k, t := range r {
		switch t {
		case ADD, SUB, MUL, DIV:
			var a, b string
			a, s = s[len(s)-1], s[:len(s)-1]
			b, s = s[len(s)-1], s[:len(s)-1]
			if k == len(r)-1 {
				s = append(s, b+mop[t]+a)
			} else {
				s = append(s, &quot;(&quot;+b+mop[t]+a+&quot;)&quot;)
			}
		default:
			s = append(s, strconv.Itoa(t))
		}
	}
	for _, v := range s {
		ret += v
	}
	return
}

func rpncalc(r []int) (int, bool) {
	stack.Reset()
	for _, t := range r {
		switch t {
		case ADD, SUB, MUL, DIV:
			if stack.Len() &lt; 2 {
				return 0, false
			}
			a := stack.Pop()
			b := stack.Pop()
			if t == ADD {
				stack.Push(b + a)
			}
			if t == SUB {
				// disallow negative subresults
				if b-a &lt; 0 {
					return 0, false
				}
				stack.Push(b - a)
			}
			if t == MUL {
				stack.Push(b * a)
			}
			if t == DIV {
				if a == 0 {
					return 0, false
				}
				// disallow fractions
				if b%a != 0 {
					return 0, false
				}
				stack.Push(b / a)
			}
		default:
			stack.Push(t)
		}
	}
	if stack.Len() == 1 { // there is only one!
		return stack.Pop(), true
	}
	return 0, false
}
</code></pre>
</section>
<section data-matter="back"><h1 id="bibliography-section">Bibliography</h1>
<div class="bibliography">
<dl>
<dt class="bibliography-cite" id="RFC1196">[RFC1196]</dt>
<dd></dd>
<dt class="bibliography-cite" id="RFC4627">[RFC4627]</dt>
<dd></dd>
<dt class="bibliography-cite" id="bubblesort">[bubblesort]</dt>
<dd><span class="bibliography-author">Wikipedia</span>
<span class="bibliography-title">Bubble sort</span>
<date class="bibliography-date">2010</date>
</dd>
<dt class="bibliography-cite" id="csp">[csp]</dt>
<dd><span class="bibliography-author">C. A. R. Hoare</span>
<span class="bibliography-title">Communicating sequential processes (csp)</span>
<date class="bibliography-date">1985</date>
</dd>
<dt class="bibliography-cite" id="duck_typing">[duck_typing]</dt>
<dd><span class="bibliography-author">Wikipedia</span>
<span class="bibliography-title">Duck typing</span>
<date class="bibliography-date">2010</date>
</dd>
<dt class="bibliography-cite" id="effective_go">[effective_go]</dt>
<dd><span class="bibliography-author">Go Authors</span>
<span class="bibliography-title">Effective Go</span>
<date class="bibliography-date">2010</date>
</dd>
<dt class="bibliography-cite" id="fizzbuzz">[fizzbuzz]</dt>
<dd><span class="bibliography-author">Imran On Tech</span>
<span class="bibliography-title">Using fizzbuzz to find developers...</span>
<date class="bibliography-date">2010</date>
</dd>
<dt class="bibliography-cite" id="go_1_5_release_notes">[go_1_5_release_notes]</dt>
<dd><span class="bibliography-author">Go Authors</span>
<span class="bibliography-title">Go 1.5 Release Notes</span>
<date class="bibliography-date">2010</date>
</dd>
<dt class="bibliography-cite" id="go_blog_panic">[go_blog_panic]</dt>
<dd><span class="bibliography-author">Go Authors</span>
<span class="bibliography-title">Defer, panic, and recover</span>
<date class="bibliography-date">2010</date>
</dd>
<dt class="bibliography-cite" id="go_course_day3">[go_course_day3]</dt>
<dd><span class="bibliography-author">Rob Pike</span>
<span class="bibliography-title">The Go programming language, day 3</span>
<date class="bibliography-date">2010</date>
</dd>
<dt class="bibliography-cite" id="go_interfaces">[go_interfaces]</dt>
<dd><span class="bibliography-author">Ian Lance Taylor</span>
<span class="bibliography-title">Go interfaces</span>
<date class="bibliography-date">2010</date>
</dd>
<dt class="bibliography-cite" id="go_nuts_interfaces">[go_nuts_interfaces]</dt>
<dd><span class="bibliography-author">Go Community</span>
<span class="bibliography-title">Function accepting a slice of interface types</span>
<date class="bibliography-date">2010</date>
</dd>
<dt class="bibliography-cite" id="go_spec">[go_spec]</dt>
<dd><span class="bibliography-author">Go Authors</span>
<span class="bibliography-title">Go language specification</span>
<date class="bibliography-date">2010</date>
</dd>
<dt class="bibliography-cite" id="go_tutorial">[go_tutorial]</dt>
<dd><span class="bibliography-author">Go Authors</span>
<span class="bibliography-title">Go tutorial</span>
<date class="bibliography-date">2010</date>
</dd>
<dt class="bibliography-cite" id="go_web">[go_web]</dt>
<dd><span class="bibliography-author">Go Authors</span>
<span class="bibliography-title">Go website</span>
<date class="bibliography-date">2010</date>
</dd>
<dt class="bibliography-cite" id="iota">[iota]</dt>
<dd><span class="bibliography-author">Wikipedia</span>
<span class="bibliography-title">Iota</span>
<date class="bibliography-date">2010</date>
</dd>
</dl>
<h1 id="footnote-section">Footnotes</h1>

<div class="footnotes">


<ol>
<li id="fn:Yes-that-sounds">Yes, that sounds a lot like *co*routines, but goroutines are slightly different as we will see in <a href="#communication"></a>. <a class="footnote-return" href="#fnref:Yes-that-sounds"><sup>[return]</sup></a></li>

<li id="fn:http-play-golang"><a href="http://play.golang.org">http://play.golang.org</a>. <a class="footnote-return" href="#fnref:http-play-golang"><sup>[return]</sup></a></li>

<li id="fn:http-golang-org"><a href="http://golang.org/doc/">http://golang.org/doc/</a> itself is served by <code>godoc</code>. <a class="footnote-return" href="#fnref:http-golang-org"><sup>[return]</sup></a></li>

<li id="fn:When-building-fr">When building from source it must be installed separately with <code>go get golang.org/x/tools/cmd/godoc</code>. <a class="footnote-return" href="#fnref:When-building-fr"><sup>[return]</sup></a></li>

<li id="fn:The-word-iota-is">The word iota is used in a common English phrase, &lsquo;not one iota&rsquo;, meaning &lsquo;not the slightest difference&rsquo;, in reference to a phrase in the New Testament: &ldquo;<em>until heaven and earth pass away, not an iota, not a dot, will pass from the Law</em>.&rdquo; <cite class="informative"><a href="#iota"><sup>[iota]</sup></a></cite> <a class="footnote-return" href="#fnref:The-word-iota-is"><sup>[return]</sup></a></li>

<li id="fn:In-the-UTF-8-wor">In the UTF-8 word <em>characters</em> are sometimes called <em>runes</em> <span class="index" id="idxref:133"></span> Mostly, when people talk about characters, they mean 8 bit characters. As UTF-8 characters may be up to 32 bits the word rune is used. <a class="footnote-return" href="#fnref:In-the-UTF-8-wor"><sup>[return]</sup></a></li>

<li id="fn:You-can-use-the">You can use the command <code>godoc builtin</code> to read the online documentation about the built-in types and functions. <a class="footnote-return" href="#fnref:You-can-use-the"><sup>[return]</sup></a></li>

<li id="fn:Always-rainy-in">Always rainy in March anyway. <a class="footnote-return" href="#fnref:Always-rainy-in"><sup>[return]</sup></a></li>

<li id="fn:This-is-a-motto">This is a motto of Go; &ldquo;Do <em>more</em> with <em>less</em> code&rdquo;. <a class="footnote-return" href="#fnref:This-is-a-motto"><sup>[return]</sup></a></li>

<li id="fn:A-function-liter">A function literal is sometimes called a closure <span class="index" id="idxref:134"></span>. <a class="footnote-return" href="#fnref:A-function-liter"><sup>[return]</sup></a></li>

<li id="fn:Modified-from-a">Modified from a presentation of Eleanor McHugh. <a class="footnote-return" href="#fnref:Modified-from-a"><sup>[return]</sup></a></li>

<li id="fn:The-descriptions">The descriptions are copied from the packages&rsquo; <code>go doc</code>. <a class="footnote-return" href="#fnref:The-descriptions"><sup>[return]</sup></a></li>

<li id="fn:The-downside-is">The downside is that you know have to worry about garbage collection. If you really need it garbage collection in a Go program can be disabled by running it with the environment variable <code>GOGC</code> set to <code>off</code>: <code>GOGC=off ./myprogram</code>. <a class="footnote-return" href="#fnref:The-downside-is"><sup>[return]</sup></a></li>

<li id="fn:Taking-the-addre">Taking the address of a composite literal tells the compiler to allocate it on the heap, not the stack. <a class="footnote-return" href="#fnref:Taking-the-addre"><sup>[return]</sup></a></li>

<li id="fn:Also-see-methods">Also see <a href="#methods"></a> in this chapter. <a class="footnote-return" href="#fnref:Also-see-methods"><sup>[return]</sup></a></li>

<li id="fn:The-following-te">The following text is partly from <cite class="informative"><a href="#go_interfaces"><sup>[go_interfaces]</sup></a></cite>. <a class="footnote-return" href="#fnref:The-following-te"><sup>[return]</sup></a></li>

<li id="fn:Text-copied-from">Text copied from <cite class="informative"><a href="#effective_go"><sup>[effective_go]</sup></a></cite>. <a class="footnote-return" href="#fnref:Text-copied-from"><sup>[return]</sup></a></li>

<li id="fn:go-doc-reflect"><code>go doc reflect</code> <a class="footnote-return" href="#fnref:go-doc-reflect"><sup>[return]</sup></a></li>

<li id="fn:In-case-you-are">In case you are wondering, 192.0.32.10 and 2620:0:2d0:200::10 are <a href="http://www.example.org">http://www.example.org</a>. <a class="footnote-return" href="#fnref:In-case-you-are"><sup>[return]</sup></a></li>

<li id="fn:The-variable-con">The variable <code>conn</code> also implements a <code>close</code> method, this really makes it an <code>io.ReadWriteCloser</code>. <a class="footnote-return" href="#fnref:The-variable-con"><sup>[return]</sup></a></li>
</ol>

</div>
<h1 id="index-section">Index</h1>
<div class="index">
<dl>
<dt>a</dt>
<dd>
<ul>
<li>
array<ul>
<li>
multidimensional <a class="index-return" href="#idxref:49"><sup>[go]</sup></a></ul>
</li>
</li>
</ul>
</dd>
</dl>
<dl>
<dt>b</dt>
<dd>
<ul>
<li>
built-in<ul>
<li>
close <a class="index-return" href="#idxref:33"><sup>[go]</sup></a></li>
<li>
delete <a class="index-return" href="#idxref:34"><sup>[go]</sup></a></li>
<li>
len <a class="index-return" href="#idxref:35"><sup>[go]</sup></a></li>
<li>
cap <a class="index-return" href="#idxref:36"><sup>[go]</sup></a></li>
<li>
new <a class="index-return" href="#idxref:37"><sup>[go]</sup></a> <a class="index-return" href="#idxref:100"><sup>[go]</sup></a></li>
<li>
make <a class="index-return" href="#idxref:38"><sup>[go]</sup></a> <a class="index-return" href="#idxref:101"><sup>[go]</sup></a></li>
<li>
copy <a class="index-return" href="#idxref:39"><sup>[go]</sup></a> <a class="index-return" href="#idxref:55"><sup>[go]</sup></a></li>
<li>
append <a class="index-return" href="#idxref:40"><sup>[go]</sup></a> <a class="index-return" href="#idxref:54"><sup>[go]</sup></a></li>
<li>
panic <a class="index-return" href="#idxref:41"><sup>[go]</sup></a></li>
<li>
recover <a class="index-return" href="#idxref:42"><sup>[go]</sup></a></li>
<li>
print <a class="index-return" href="#idxref:44"><sup>[go]</sup></a></li>
<li>
complex <a class="index-return" href="#idxref:46"><sup>[go]</sup></a></li>
<li>
real <a class="index-return" href="#idxref:47"><sup>[go]</sup></a></li>
<li>
imag <a class="index-return" href="#idxref:48"><sup>[go]</sup></a></ul>
</li>
</li>
</ul>
</dd>
</dl>
<dl>
<dt>c</dt>
<dd>
<ul>
<li>
channel<ul>
<li>
unbuffered <a class="index-return" href="#idxref:121"><sup>[go]</sup></a></li>
<li>
blocking read <a class="index-return" href="#idxref:122"><sup>[go]</sup></a></li>
<li>
blocking write <a class="index-return" href="#idxref:123"><sup>[go]</sup></a></li>
<li>
non-blocking read <a class="index-return" href="#idxref:124"><sup>[go]</sup></a></li>
<li>
non-blocking write <a class="index-return" href="#idxref:125"><sup>[go]</sup></a></ul>
</li>
</li>
<li>
channels <a class="index-return" href="#idxref:1"><sup>[go]</sup></a> <a class="index-return" href="#idxref:119"><sup>[go]</sup></a></li>
<li>
closure <a class="index-return" href="#idxref:134"><sup>[go]</sup></a></li>
<li>
complex numbers <a class="index-return" href="#idxref:45"><sup>[go]</sup></a></li>
</ul>
</dd>
</dl>
<dl>
<dt>d</dt>
<dd>
<ul>
<li>
duck<ul>
<li>
typing <a class="index-return" href="#idxref:112"><sup>[go]</sup></a></ul>
</li>
</li>
</ul>
</dd>
</dl>
<dl>
<dt>f</dt>
<dd>
<ul>
<li>
field <a class="index-return" href="#idxref:105"><sup>[go]</sup></a></li>
<li>
functions<ul>
<li>
receiver <a class="index-return" href="#idxref:61"><sup>[go]</sup></a></li>
<li>
method <a class="index-return" href="#idxref:62"><sup>[go]</sup></a></li>
<li>
pass-by-value <a class="index-return" href="#idxref:63"><sup>[go]</sup></a></li>
<li>
as values <a class="index-return" href="#idxref:66"><sup>[go]</sup></a></li>
<li>
literals <a class="index-return" href="#idxref:67"><sup>[go]</sup></a></li>
<li>
signature <a class="index-return" href="#idxref:68"><sup>[go]</sup></a></li>
<li>
literal <a class="index-return" href="#idxref:71"><sup>[go]</sup></a></li>
<li>
variadic <a class="index-return" href="#idxref:72"><sup>[go]</sup></a></li>
<li>
exported <a class="index-return" href="#idxref:75"><sup>[go]</sup></a></li>
<li>
private <a class="index-return" href="#idxref:76"><sup>[go]</sup></a></li>
<li>
public <a class="index-return" href="#idxref:77"><sup>[go]</sup></a></ul>
</li>
</li>
</ul>
</dd>
</dl>
<dl>
<dt>g</dt>
<dd>
<ul>
<li>
generic <a class="index-return" href="#idxref:115"><sup>[go]</sup></a></li>
<li>
goroutine <a class="index-return" href="#idxref:0"><sup>[go]</sup></a> <a class="index-return" href="#idxref:117"><sup>[go]</sup></a></li>
</ul>
</dd>
</dl>
<dl>
<dt>i</dt>
<dd>
<ul>
<li>
interface <a class="index-return" href="#idxref:108"><sup>[go]</sup></a><ul>
<li>
set of methods <a class="index-return" href="#idxref:109"><sup>[go]</sup></a></li>
<li>
type <a class="index-return" href="#idxref:110"><sup>[go]</sup></a></li>
<li>
value <a class="index-return" href="#idxref:111"><sup>[go]</sup></a></ul>
</li>
</li>
<li>
io<ul>
<li>
buffered <a class="index-return" href="#idxref:126"><sup>[go]</sup></a></ul>
</li>
</li>
<li>
io.Reader <a class="index-return" href="#idxref:128"><sup>[go]</sup></a></li>
</ul>
</dd>
</dl>
<dl>
<dt>k</dt>
<dd>
<ul>
<li>
keywords<ul>
<li>
iota <a class="index-return" href="#idxref:9"><sup>[go]</sup></a></li>
<li>
if <a class="index-return" href="#idxref:18"><sup>[go]</sup></a></li>
<li>
return <a class="index-return" href="#idxref:19"><sup>[go]</sup></a></li>
<li>
else <a class="index-return" href="#idxref:20"><sup>[go]</sup></a></li>
<li>
goto <a class="index-return" href="#idxref:21"><sup>[go]</sup></a></li>
<li>
for <a class="index-return" href="#idxref:23"><sup>[go]</sup></a></li>
<li>
break <a class="index-return" href="#idxref:24"><sup>[go]</sup></a></li>
<li>
continue <a class="index-return" href="#idxref:25"><sup>[go]</sup></a></li>
<li>
range <a class="index-return" href="#idxref:26"><sup>[go]</sup></a> <a class="index-return" href="#idxref:27"><sup>[go]</sup></a> <a class="index-return" href="#idxref:28"><sup>[go]</sup></a> <a class="index-return" href="#idxref:57"><sup>[go]</sup></a></li>
<li>
switch <a class="index-return" href="#idxref:29"><sup>[go]</sup></a></li>
<li>
fallthrough <a class="index-return" href="#idxref:30"><sup>[go]</sup></a></li>
<li>
default <a class="index-return" href="#idxref:31"><sup>[go]</sup></a></li>
<li>
map <a class="index-return" href="#idxref:56"><sup>[go]</sup></a></li>
<li>
map adding elements <a class="index-return" href="#idxref:58"><sup>[go]</sup></a></li>
<li>
map
existence <a class="index-return" href="#idxref:59"><sup>[go]</sup></a></li>
<li>
map remove elements <a class="index-return" href="#idxref:60"><sup>[go]</sup></a></li>
<li>
defer <a class="index-return" href="#idxref:69"><sup>[go]</sup></a></li>
<li>
defer list <a class="index-return" href="#idxref:70"><sup>[go]</sup></a></li>
<li>
package <a class="index-return" href="#idxref:74"><sup>[go]</sup></a></li>
<li>
import <a class="index-return" href="#idxref:78"><sup>[go]</sup></a></li>
<li>
type <a class="index-return" href="#idxref:103"><sup>[go]</sup></a></li>
<li>
struct <a class="index-return" href="#idxref:104"><sup>[go]</sup></a></li>
<li>
go <a class="index-return" href="#idxref:118"><sup>[go]</sup></a></ul>
</li>
</li>
</ul>
</dd>
</dl>
<dl>
<dt>l</dt>
<dd>
<ul>
<li>
label <a class="index-return" href="#idxref:22"><sup>[go]</sup></a></li>
<li>
literal<ul>
<li>
composite <a class="index-return" href="#idxref:50"><sup>[go]</sup></a> <a class="index-return" href="#idxref:102"><sup>[go]</sup></a></ul>
</li>
</li>
</ul>
</dd>
</dl>
<dl>
<dt>m</dt>
<dd>
<ul>
<li>
methods<ul>
<li>
inherited <a class="index-return" href="#idxref:106"><sup>[go]</sup></a></ul>
</li>
</li>
</ul>
</dd>
</dl>
<dl>
<dt>n</dt>
<dd>
<ul>
<li>
networking<ul>
<li>
Dial <a class="index-return" href="#idxref:132"><sup>[go]</sup></a></ul>
</li>
</li>
<li>
nil <a class="index-return" href="#idxref:97"><sup>[go]</sup></a></li>
</ul>
</dd>
</dl>
<dl>
<dt>o</dt>
<dd>
<ul>
<li>
operators<ul>
<li>
bitwise and <a class="index-return" href="#idxref:11"><sup>[go]</sup></a></li>
<li>
bitwise or <a class="index-return" href="#idxref:12"><sup>[go]</sup></a></li>
<li>
bit wise xor <a class="index-return" href="#idxref:13"><sup>[go]</sup></a></li>
<li>
bitwise clear <a class="index-return" href="#idxref:14"><sup>[go]</sup></a></li>
<li>
and <a class="index-return" href="#idxref:15"><sup>[go]</sup></a></li>
<li>
or <a class="index-return" href="#idxref:16"><sup>[go]</sup></a></li>
<li>
not <a class="index-return" href="#idxref:17"><sup>[go]</sup></a></li>
<li>
address-of <a class="index-return" href="#idxref:98"><sup>[go]</sup></a></li>
<li>
increment <a class="index-return" href="#idxref:99"><sup>[go]</sup></a></li>
<li>
channel <a class="index-return" href="#idxref:120"><sup>[go]</sup></a></ul>
</li>
</li>
</ul>
</dd>
</dl>
<dl>
<dt>p</dt>
<dd>
<ul>
<li>
package <a class="index-return" href="#idxref:73"><sup>[go]</sup></a><ul>
<li>
builtin <a class="index-return" href="#idxref:32"><sup>[go]</sup></a></li>
<li>
fmt <a class="index-return" href="#idxref:43"><sup>[go]</sup></a> <a class="index-return" href="#idxref:83"><sup>[go]</sup></a></li>
<li>
bytes <a class="index-return" href="#idxref:79"><sup>[go]</sup></a></li>
<li>
bufio <a class="index-return" href="#idxref:80"><sup>[go]</sup></a> <a class="index-return" href="#idxref:85"><sup>[go]</sup></a> <a class="index-return" href="#idxref:127"><sup>[go]</sup></a></li>
<li>
ring <a class="index-return" href="#idxref:81"><sup>[go]</sup></a></li>
<li>
io <a class="index-return" href="#idxref:84"><sup>[go]</sup></a> <a class="index-return" href="#idxref:129"><sup>[go]</sup></a></li>
<li>
sort <a class="index-return" href="#idxref:86"><sup>[go]</sup></a></li>
<li>
strconv <a class="index-return" href="#idxref:87"><sup>[go]</sup></a></li>
<li>
os <a class="index-return" href="#idxref:88"><sup>[go]</sup></a></li>
<li>
sync <a class="index-return" href="#idxref:89"><sup>[go]</sup></a></li>
<li>
flag <a class="index-return" href="#idxref:90"><sup>[go]</sup></a> <a class="index-return" href="#idxref:130"><sup>[go]</sup></a></li>
<li>
encoding/json <a class="index-return" href="#idxref:91"><sup>[go]</sup></a></li>
<li>
html/template <a class="index-return" href="#idxref:92"><sup>[go]</sup></a></li>
<li>
net/http <a class="index-return" href="#idxref:93"><sup>[go]</sup></a></li>
<li>
unsafe <a class="index-return" href="#idxref:94"><sup>[go]</sup></a></li>
<li>
reflect <a class="index-return" href="#idxref:95"><sup>[go]</sup></a> <a class="index-return" href="#idxref:116"><sup>[go]</sup></a></li>
<li>
os/exec <a class="index-return" href="#idxref:96"><sup>[go]</sup></a> <a class="index-return" href="#idxref:131"><sup>[go]</sup></a></ul>
</li>
</li>
</ul>
</dd>
</dl>
<dl>
<dt>r</dt>
<dd>
<ul>
<li>
reference types <a class="index-return" href="#idxref:51"><sup>[go]</sup></a></li>
<li>
runes <a class="index-return" href="#idxref:10"><sup>[go]</sup></a> <a class="index-return" href="#idxref:133"><sup>[go]</sup></a></li>
</ul>
</dd>
</dl>
<dl>
<dt>s</dt>
<dd>
<ul>
<li>
scope<ul>
<li>
local <a class="index-return" href="#idxref:64"><sup>[go]</sup></a> <a class="index-return" href="#idxref:65"><sup>[go]</sup></a></ul>
</li>
</li>
<li>
slice<ul>
<li>
capacity <a class="index-return" href="#idxref:52"><sup>[go]</sup></a></li>
<li>
length <a class="index-return" href="#idxref:53"><sup>[go]</sup></a></ul>
</li>
</li>
<li>
structures<ul>
<li>
embed <a class="index-return" href="#idxref:107"><sup>[go]</sup></a></ul>
</li>
</li>
</ul>
</dd>
</dl>
<dl>
<dt>t</dt>
<dd>
<ul>
<li>
tooling<ul>
<li>
go <a class="index-return" href="#idxref:2"><sup>[go]</sup></a></li>
<li>
go build <a class="index-return" href="#idxref:3"><sup>[go]</sup></a></li>
<li>
go run <a class="index-return" href="#idxref:4"><sup>[go]</sup></a></li>
<li>
go test <a class="index-return" href="#idxref:82"><sup>[go]</sup></a></ul>
</li>
</li>
<li>
type assertion <a class="index-return" href="#idxref:114"><sup>[go]</sup></a></li>
<li>
type switch <a class="index-return" href="#idxref:113"><sup>[go]</sup></a></li>
</ul>
</dd>
</dl>
<dl>
<dt>v</dt>
<dd>
<ul>
<li>
variables<ul>
<li>
declaring <a class="index-return" href="#idxref:5"><sup>[go]</sup></a></li>
<li>
assigning <a class="index-return" href="#idxref:6"><sup>[go]</sup></a></li>
<li>
parallel assignment <a class="index-return" href="#idxref:7"><sup>[go]</sup></a></li>
<li>
underscore <a class="index-return" href="#idxref:8"><sup>[go]</sup></a></ul>
</li>
</li>
</ul>
</dd>
</dl>

</div>
</section>

</body>
</html>

